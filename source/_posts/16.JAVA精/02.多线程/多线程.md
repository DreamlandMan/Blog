# 线程简介

**多任务**

同时做多件事，比如边吃饭边玩手机，边开车边打电话边打点滴

事实上，大脑这一秒在吃饭，下一秒玩手机，只是看起来连贯而已

**多线程**

单道变成多道，原来很多任务都在一条道上跑，容易阻塞，效率极低，现在拓宽

了几条道，多条道上都有任务，没那么容易阻塞了

就好比打游戏，如果两个人只有一个账号，玩得就不开心，如果两个人有两个账

号，各玩各的，就好多了

一心两用

一个视频进程有多个线程，字幕、音乐、图象

**Process进程和Thread线程**

程序跑起来就有进程，进程是程序的一次执行过程，是动态的

一个进程包含若干线程，至少有一个，线程是CPU调度和执行的基本单位

很多多线程都是模拟出来的，CPU在线程之间快速切换，一个时间点其实只能执

行一个线程，造成一种并发执行的假象，真正的多线程其实是指多核CPU

线程是独立执行的路径

即使Java程序运行时没有创建线程，也会有主（Main）线程和GC线程

主函数是程序的入口

线程由CPU调度，不能人为干预

多个线程操作同一份资源时，会存在资源抢夺，需要加入并发控制

线程会带来额外的开销，如CPU调度开销、并发控制开销

线程都在自己的工作线程中交互，内存控制不当会造成数据不一致

# 线程创建

线程创建方式有三种：继承Thread类、实现Runnable接口、实现Callable接口

**继承Thread类**

定义一个类继承Thread类重写run方法

创建继承类的实例，调用start()方法

线程开启后不一定立即执行，由CPU调度执行

**Thread类中的常用方法**

- start():启动当前线程(即调用start方法的线程)，并调用当前线程的run方法

- run():通常需要进行重写，将创建的线程需要执行的操作写在run方法中

- currentThread():是静态方法，这么用：Thread.currentThread()用来返回执行这一行代码的线程，返回类型为Thread

  - 获取所有线程

    ```java
    ThreadGroup currentGroup = 
        Thread.currentThread().getThreadGroup();
    int noThreads = currentGroup.activeCount();
    Thread[] lstThreads = new Thread[noThreads];
    currentGroup.enumerate(lstThreads);
    for (int i = 0; i < noThreads; i++)
        System.out.println("线程号：" + i + " = " + lstThreads[i].getName());
    ```

- getName():获取当前线程的名字

- setName():设置当前线程的名字,记得要在start方法之前进行。

- 还可以利用构造器给线程起名字

- yield():释放当前CPU的执行权

- join():在线程a中调用线程b的join方法，使得线程a进入阻塞状态（CPU想让它执行也执行不了）直到线程b完全执行完，线程a才结束阻塞状态

- stop():强制线程生命期结束（不是阻塞），不推荐使用，API中已被废弃

- sleep(long millitime):是静态方法，让当前的线程阻塞指定的毫秒数。传入的参数是毫秒(1秒=1000毫秒)，比如想让线程休息(阻塞)1秒，就写1000。经常在显示倒计时的程序中使用

- isAlive():判断当前线程是否还存活（执行完run方法之后线程就死亡了）

# 网图下载

导入commons-io-2.6.jar

使用FileUtils.copyUrlToFile(Url url,File file) 将这个URL指向的文件复制到file

文件中，实现下载功能

# 实现Runnable接口

创建一个类实现Runnable接口，重写run方法

开启run方法线程，需要创建一个Thread类对象，构造参数为Runnable接口实现类实例，Thread类对象调用start方法

其实Thread类本身就实现了Runnable接口

适用场景：当Runnable接口实现类需要继承其他类时，采用实现接口的方法，因为Java没有多继承，避免OOP单继承局限

实现Runnable接口的类因为没有继承Thread，不能再使用this.currentThread()获取自身线程了。要使用Thread.currentThread()获取

推荐使用实现Runnable接口的方法创建线程

# 初识并发问题

实现Runnable接口的类，可以做到多个线程操作同一个对象

创建Thread对象，构造参数传入Runnable实现类实例和String类型的线程名，创建时可以设置该线程的名称

线程执行太快可以使用Thread.sleep(long ms)方法模拟延时

run方法中使用Thread Thread.currentThread()方法可以获取当前在运行的线程

例子：创建10张票，run方法抢票减少一张票，创建三个线程传入同一个Runnable实现类实例，三个线程操作同一个对象抢票

预期结果：三个线程抢完票后，三者的票不重复，三者的总票数等于10

实际：

- 有的线程抢到了同一张票，三者总票数大于10，可能还会出现抢到第-1张票

- 因为多个当线程执行完都发现主内存中的票数大于0，所以在自己的工作内存中对抢了票，造成同一张票被多次拿了

问题：多个线程操作同一个对象，同一个资源的情况下，线程不安全，数据会混乱

# 实现Callable接口

了解即可

实现Callable接口需要传入泛型

实现Callable接口需要重写的方法不是run方法了，而是call方法，call方法有返回类型，这个类型就是Callable接口的泛型

开启线程

- ExecutorService Executors.newFixedThreadPool(int i)创建执行服务，创建线程池，i为池中最大线程数
- Future<Callable接口泛型> executorService.submit(Callable接口实现类对象)提交执行，返回执行结果，可以提交多个传入同一个实现类对象，做到多个线程操作一个对象
- Callable接口泛型 future.get()得到执行结果
- executorService.shutdownNow()关闭服务

简便开启线程：

- FutureTask<T> f = new FutureTask<T>(Callable<T> c);
- new Thread(f).start();
- T futureTask.get() 获取Callable线程的执行结果

好处

- 可以定义返回值
- 可以抛出异常

# 静态代理模式

创建一个吃东西接口Eat，定义eat方法

创建一个吃肉类EatMeat类实现Eat接口，重写eat方法

创建一个代理类EatProxy实现Eat接口，构造参数为Eat接口对象，注意，传入的对象可以是参数对象的实现类或继承子类

代理中定义before方法和after方法

代理类重写eat方法作为代理方法，方法中调用参数Eat接口的eat方法，在eat方法前后调用before和after方法，类似Spring的通知

静态代理的作用：对象只需要做好自己的事，代理类对对象的功能进行增强

举例：

- EatMeat类中eat方法体为打印"吃肉"，EatProxy类的before方法体为打印"从冰箱取肉做熟"，after方法体为打印"收拾碗筷"，eat方法体为依次调用before方法、参数接口的eat方法、after方法
- 实例化时，创建接口实现类对象，再创建代理类对象构造参数
- 为接口实现类对象，代理类对象调用eat方法

Thread类其实就是使用静态代理模式，它其实就是个代理类

它实现了Runnable接口，实例化Thread类需要传入Runnable接口实现类对象，该对象重写了run方法

最后Thread对象再调用start代理方法开启线程，本质上还是在执行run方法

# 线程状态

创建状态——(启动线程)——＞就绪状态：实例化Thread对象

就绪状态——(获得CPU资源)——＞运行状态：调度

运行状态——(释放CPU资源)——＞就绪状态：调度

运行状态——(线程自然执行完毕、外部干涉终止线程)——＞死亡状态：中断或结束

运行状态——(等待用户输入、线程休眠等)——＞阻塞状态：调用sleep方法、wait方法或同步锁定后

阻塞状态——(阻塞解除)——＞就绪状态：调用start方法

线程状态观测：Thread.State枚举

- NEW：尚未启动的线程状态，未调用start方法的线程
- RUNNABLE：在虚拟机中执行的线程状态，包含了就绪状态
- BLOCKED：被阻塞等待监视器锁定的线程状态
- WAITING：正在等待另一线程执行指定动作的线程状态
- TIMED_WAITING：正在等待另一线程执行到指定时间的线程状态，Thread.sleep()的线程处于此状态
- TERMINATED：已退出的线程状态
  - 结束之后的线程不能再start开启，会报错IllegalThreadStatException

Thread类方法

- voidsetPriority(int x) 设置线程优先级

- static void sleep(long ms) 线程休眠指定毫秒

  - 1000ms=1s

  - sleep结束后进入就绪状态

  - 可以模拟网络延时(放大问题的发生性，看不出

  - 线程并发问题可以延时一下)、倒计时
  - 每个对象都有一把锁，sleep不会释放锁

- void join() 合并线程

  - 此线程插队立即执行

  - 其它线程阻塞，等待插队线程执行完毕

- static void yield() 礼让

  - 暂停当前执行的线程，先执行其他线程

  - 让CPU重新调度，礼让不一定成功，好比坐公交，有老人们上来了，你站起来让座，然后跟老人一起抢位置，可能还是你抢到了

- void interrupt() 中断线程

  - 别用这个方式，同样不推荐stop和destroy方法

  - 建议让线程自己停止，或者定义一个标志位终止变量，当flag=false时跳出while循环终止线程运行

- boolean isAlive() 判断该线程是否处于活动状态

# 线程优先级

优先级Priority

CPU在就绪队列中，按照优先级从就绪队列中，决定调度哪个线程

优先级从1到10，1最低，10最高

- 越高越有可能先执行，并不是说优先级越高就一定最先执行，还是要看CPU调度，有可能出现性能倒置现象（实践看看）
- Thread.MAX_PRIORITY=10
- Thread.MIN_PRIORITY=1
- Thread.NORM_PRIORITY=5
- thread.getPriority().setPriority(int x) 设置线程优先级，建议在start方法前调用

# 守护线程

守护（daemon）线程

线程分为用户线程和守护线程

虚拟机必须确保用户线程执行完毕，不用等待守护线程执行完毕

用户线程如Main线程，守护线程如GC、操作日志、监控内存

thread.setDaemon(boolean b) 设置守护线程，false为用户线程，true为守护线程

# 线程同步机制

线程同步（并发问题）：多个线程操作同一个资源情况下

多个线程操作同一个资源时，原本的调度机制是资源抢夺，谁抢到就是谁的，容易造成数据混乱，需要线程同步，需要队列，排队一个个来

线程同步其实就是一种等待机制，多个需要访问这个对象的线程进入这个对象的等待池，等待前面的线程使用完毕，下一个线程再使用

队列+锁：

- 用于保证线程安全性
- 锁机制：synchronized，当一个线程获得对象的排它锁，独占资源，其它线程等待
- 就好比排队上厕所，一次只能进一个，前面进去的人把门锁上，下一个人在外面等他出来才能进去
- 问题：
  - 一个线程持有锁导致其它需要锁的线程挂起，降低了性能
  - 一个优先级高的线程等待优先级低的线程释放锁，会导致优先级倒置，引起性能问题

# 三大不安全案例

看似安全的情况下，将线程sleep一会儿就可能出问题，放大问题发生性

不安全买票

- 创建线程，定义int类型票数等于10，run方法写当票数大于0时，while循环不断抢票，票数减减，打印哪个线程拿到了票。
- 问题：
  - 有几个线程拿到了同一张票
  - 有线程抢到了第-1张票
- 不安全原因：当票只剩最后一张的时候，多个线程发现还有票，便将数据在自己的工作内存中操作，最后一张的情况下被多次取票，导致1-1-1=-1

不安全的银行取款

- 余额为100元，甲取50，乙取100，二者同时取款
- 开启线程后，有可能甲乙同时取，导致最后取出150元，余额为-50
- 不安全的原因：甲乙同时操作数据，同时发现余额为100，满足自身取款要求，于是在自己的工作内存中操作数据，100-50-100=-50，造成数据同时被甲乙操作导致混乱

不安全的集合

- 创建一个List
- 创建一个for循环，循环一万次，每次循环用Lamda表达式创建一个线程，将线程方法体中，将自身线程名称存入集合
- 最后打印集合的size大小，发现并没有一万个
- 不安全原因：
  - 可能是主线程太快执行完毕，for循环中创建的线程有的还没有start，for循环后主线程需要sleep一会儿
  - 虽然线程是按照for循环以此创建的，但是线程start是根据CPU调度的，可能多个线程并发，同时add在了集合的同一个index下标，导致覆盖

# 同步方法及同步块

synchronized关键字

同步方法

- 普通方法加上synchronized关键字后，会变成同步方法：`public synchronized void haha(){}`
- 每个对象都有一把锁，如果加了synchronized关键字，第一个访问对象的线程访问到这个方法，会独占该锁，其它线程执行到这个方法会阻塞，必须要等待第一个对象释放锁然后其它线程获取到锁才能继续执行
- 将一个大的方法声明为synchronized，会大大影响效率

同步块

- synchronized默认锁的是this指向的对象，锁的是方法所在类本身的实例
- 而有些时候我们线程操作的对象数据并不是this，而是某个对象数据
  - `synchronized (obj){}`，obj是同步监视器，一般是想要修改的资源，这个资源必须是引用类型，基本类型数据要装箱，比如说不安全银行取款案例里的余额，将对这个数据操作的代码放在大括号里面
- 获取对象锁进入同步块，离开同步块释放对象锁
- 同步方法和同步块执行后可以sleep一段时间，能够使当前线程阻塞一会儿，让其他线程有机会抢到对象的锁

# CopyOnWriteArrayList

CopyOnWriteArrayList是jdk的JUC并发包的一个类，之前学过的Callable接口也在这个包

这个对象使用和普通的ArrayList没什么差别，但是它是线程安全的，就像ArrayList对象作为同步监视器被synchronized同步块同步一样

线程安全的集合类分为两大类：

- 以Concurrent开头的集合类: 如 ConcurrentHashMap、ConcurrentLinkedQueue、ConcurrentLinkedDeque、ConcurrentSkipListMap和ConcurrentSkipListSet .

- 以CopyOnWrite开头的集合类:如 CopyOnWriteArrayList、CopyOnWriteArraySet

# 死锁

两个或多个线程都需要对方释放的资源才能继续运行

产生死锁的四个必要条件

- 互斥条件：一个资源只能被一个进程使用
- 请求与保持条件：一个进程阻塞时，对已获得的资源保持不放
- 不可剥夺条件：线程获得资源，在使用完之前，不能强行剥夺
- 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系

- 四个必要条件齐全一定死锁，避免死锁要破坏必要条件

就比如你去找工作：

- 你没有工作经验我怎么要你?
- 可我不工作哪来的工作经验?

也比如想谈恋爱

- 如果她减肥我就去追她
- 如果他追我我就去减肥

synchronized同步块，同步块就是一个获取对象锁进入同步块和离开同步块释放锁的操作

死锁实例

- 创建两个static对象，AB，保证获取锁时，获取的排它锁是唯一对象的
- 创建两个线程，一个线程先synchronized监控A对象，A同步块中sleep一秒后synchronized监控对象B，另一个线程先synchronized监控对象B，B同步块中sleep一秒后synchronized监控对象A
- 这样两个线程获取到AB的锁，之后又因为对方线程持有另一个对象导致获取不到锁，都阻塞了

# Lock锁

synchronized是隐式锁，看不到锁了哪个对象，也看不到锁的开始和结束

Lock是显式锁，Lock接口在JUC包下

ReentrantLock类（可重入锁）实现了Lock接口，它拥有和synchronized相同的并发性和内存语义，在线程安全中更常用ReentrantLock来显示加锁和释放锁

用法：

- 在线程类中创建一个private final ReentrantLock对象
- run方法中，用try{}finally{}代码块将可能发生并发问题的代码括起来，try代码块前调用reentrantlock.lock()方法加锁，finally代码块中调用reentrantLock.unlock()方法解锁，别忘记释放锁了

ReentrantLock和synchronized的区别

ReentrantLock是显式锁，要手动开启和关闭锁，别忘记关闭了，synchronized是隐式锁，出了代码块作用域自动释放锁

ReentrantLock只作用于代码块，synchronized可以作用于代码块和方法

使用Lock锁，jvm将花费较少的时间来调度线程，效率更好，且具有更好的可拓展性（有更多的子类）

优选使用顺序：Lock＞同步块＞同步方法

**ReentrantLock类常用方法**

- await(time) 和 awaitUntil()：这俩个方法和synchronized的wait(long)和相似, 就是wait等待一段时间, 可以提前唤醒, 也可以等时间到了自动唤醒
- awaitUninterruptibly()：我没在普通使用await的时候, 如果这个线程中断了, 就会抛出异常, 但是使用awaitUninterruptibly()即使在等待中的线程被打断了, 也不会抛出异常
- getHoldCount()：查询当前被这个锁锁定的线程个数, 也就是这个锁执行lock的次数
- getQueueLength()：想要获取这个锁的线程个数，比如有5个线程，1个线程首先执行await()方法，那么在调用getQueueLength()方法后返回值是4，说明有4个线程同时在等待lock 的释放。
- getWaitQueueLength()：返回等待与此锁定相关的给定条件Condition的线程估计数，比如有5个线程，每个线程都执行了同一个condition对象的await()方法，则调用getWaitQueueLengh(Condition condition)方法时返回的int值是5。
- hasQueuedThread()和方法hasQueuedThreads()
  - boolean hasQueuedThread(Thread thread) 的作用是查询指定的线程是否正在等待获取此锁定。 也就是查看指定线程想要获取锁
  - hasQueuedThreads()的作用是查询是否有线程正在等待获取此锁定。也就是这个不指定了, 而是只要有想要这把锁的就返回true
  - isFair()：判断是不是公平锁
  - isHeldByCurrentThread()：查询当前线程是否保持此锁定
- lockInterruptibly()、tryLock()和tryLock(long timeout,TimeUnit unit)
  - locklnterruptibly()：如果当前线程未被中断，则获取锁定，如果已经被中断则出现异常。 也就是我们在普通使用lock方法加锁时, 如果这个线程被中断了是不会抛出异常的, 而使用locklnterruptibly方法加锁如果这个线程中断了是会抛出异常的
  - tryLock()：仅在调用时锁定未被另一个线程保持的情况下，才获取该锁定。 本意就是我尝试去获取锁, 如果没人拿我就拿, 如果有人拿我就不要这把锁了
  - tryLock(long timeout, TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁定。 也就是我会支持一段时间去尝试那这个把锁, 在这个时间段里, 我没拿到我就不要了

# 生产者消费者问题

就好比

- 生产者消费者线程共享同一个资源
- 假设仓库只能放一件产品
- 生产者生产产品放在仓库里，消费者从仓库里取产品，二者为协作关系
- 如果仓库没产品，消费者等待，有产品消费者取走
- 如果仓库没产品，生产者生产，如果仓库有产品，生产者等待

线程通信

- 生产者消费者共享同一个资源，二者为依赖关系，互为条件
- 对于生产者，没有生产产品之前，要通知消费者等待，生产产品之后，要马上通知消费者消费
- 对于消费者，消费之后要通知生产者已经消费完毕，提醒生产者生产产品

在生产者消费者问题中，只有synchronized是不够的

- synchronized可以阻止多个线程并发更新同一个资源，实现同步
- synchronized不能实现多个线程之间的通信

- Object类方法
  - wait()：线程将一直等待，知道其它线程通知，与thread.sleep()不同，该方法会释放锁
  - wait(long ms) 等待指定毫秒
  - notify() 唤醒一个处于等待状态的线程
  - notifyAll() 唤醒所有处于等待状态的线程只能在同步方法或同步代码块中使用，否则会报IllegalMonitorStateException

# 管程法

生产者：负责生产数据的模块（可能是方法、对象、线程、进程）

消费者：负责处理数据的模块（可能是方法、对象、线程、进程）

缓冲区：消费者不能直接消费生产者生产的产品，它们之间有一个缓冲区

生产者将数据存入缓冲区，消费者从缓冲区拿出数据

代码实现

- 创建产品类和缓冲区类
- 缓冲区类定义产品数组和数组最大容量int值
- 缓冲区类定义生产者生产同步方法，方法体为判断产品数组满了，notifyAll通知生产者消费，自身wait等待，否则生产一个产品放入产品数组
- 缓冲区类定义消费者消费同步方法，如果产品数组空了，notifyAll通知生产者生产，自身wait等待，否则消费者消费，取出产品数组最后一个产品返回
- 创建生产者消费者线程，重写run方法循环调用同一个缓冲区的生产消费方法实现生产和消费功能

# 信号灯法

通过标志位解决

产品类定义产品对象和标志位

产品类创建生产者方法：判断标志位是否是false，是的话wait等待，否则生产者生产，标志位变成false，notifyAll通知消费者消费，自身wait等待

产品类消费者方法：判断标志位是否为true，是的话notifyAll通知消费者生产，自身wait等待，否则消费者消费，标志位变成true

定义生产者消费者线程，循环执行同一个产品类的生产者消费者方法

# 线程池

线程的进程创建销毁会使用大量的资源，比如并发情况下的线程，会对性能影响很大

提前创建好多个线程，放入线程池，使用时直接获取，使用完放回线程池

好处

提高了响应速度（减少了创建新线程的时间）

降低了资源消耗（重复利用线程池中的资源，不需要每次都创建）

便于线程管理

corePoolSize：线程池大小

maxNumpoolSize：最大线程数量

keepAliveTime：线程池没有任务时最多保持多长时间会销毁

线程池相关API（JDK1.5）：ExecutorService和Executors

Executors：工具类，线程池的工厂类，用于创建并返回不同类型的线程池

ExecutorService newFixedThreadPool(int nThread) 创建线程池，池中最多有多少个线程，这个nThread到底是用来干什么的？只知道不能等于0

ExecutorService：真正的线程池接口，常见子类ThreadPoolExecutor

- execute(Runnable r) 执行任务/命令，没有返回值，一般用来执行Runnable
- submit(Callable c) 执行任务/命令，有返回值，一般用来执行Callable
- shutdown() 关闭线程池

```java
/**
 * 可缓存无界线程池测试
 * 当线程池中的线程空闲时间超过60s则会自动回收该线程，核心线程数为0
 * 当任务超过线程池的线程数则创建新线程。线程池的大小上限为Integer.MAX_VALUE，
 * 可看做是无限大。
 */
@Test
public void cacheThreadPoolTest() {
    // 创建可缓存的无界线程池，可以指定线程工厂，也可以不指定线程工厂
    ExecutorService executorService = Executors.newCachedThreadPool(new testThreadPoolFactory("cachedThread"));
    for (int i = 0; i < 10; i++) {
        executorService.submit(() -> {
            print("cachedThreadPool");
            System.out.println(Thread.currentThread().getName());
                }
        );
    }
}



/**
 * 创建固定线程数量的线程池测试
 * 创建一个固定大小的线程池，该方法可指定线程池的固定大小，对于超出的线程会在LinkedBlockingQueue队列中等待
 * 核心线程数可以指定，线程空闲时间为0
 */
@Test
public void fixedThreadPoolTest() {
    ExecutorService executorService = Executors.newFixedThreadPool(5, new testThreadPoolFactory("fixedThreadPool"));
    for (int i = 0; i < 10; i++) {
        executorService.submit(() -> {
                    print("fixedThreadPool");
                    System.out.println(Thread.currentThread().getName());
                }
        );
    }
}



/**
 * 创建只有一个线程的线程池测试
 * 该方法无参数，所有任务都保存队列LinkedBlockingQueue中，核心线程数为1，线程空闲时间为0
 * 等待唯一的单线程来执行任务，并保证所有任务按照指定顺序(FIFO或优先级)执行
 */
@Test
public void singleThreadPoolTest() {
    // 创建仅有单个线程的线程池
    ExecutorService executorService = Executors.newSingleThreadExecutor(new testThreadPoolFactory("singleThreadPool"));
    for (int i = 0; i < 10; i++) {
        executorService.submit(() -> {
                    print("singleThreadPool");
                    System.out.println(Thread.currentThread().getName());
                }
        );
    }

}



/**
 * 创建定时周期执行的线程池测试
 *
 * schedule(Runnable command, long delay, TimeUnit unit)，延迟一定时间后执行Runnable任务；
 * schedule(Callable callable, long delay, TimeUnit unit)，延迟一定时间后执行Callable任务；
 * scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)，延迟一定时间后，以间隔period时间的频率周期性地执行任务；
 * scheduleWithFixedDelay(Runnable command, long initialDelay, long delay,TimeUnit unit)，与scheduleAtFixedRate()方法很类似，
 * 但是不同的是scheduleWithFixedDelay()方法的周期时间间隔是以上一个任务执行结束到下一个任务开始执行的间隔，而scheduleAtFixedRate()方法的周期时间间隔是以上一个任务开始执行到下一个任务开始执行的间隔，
 * 也就是这一些任务系列的触发时间都是可预知的。
 * ScheduledExecutorService功能强大，对于定时执行的任务，建议多采用该方法。
 *
 * 作者：张老梦
 * 链接：https://www.jianshu.com/p/9ce35af9100e
 * 来源：简书
 * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
 */
@Test
public void scheduleThreadPoolTest() {
    // 创建指定核心线程数，但最大线程数是Integer.MAX_VALUE的可定时执行或周期执行任务的线程池
    ScheduledExecutorService executorService = Executors.newScheduledThreadPool(5, new testThreadPoolFactory("scheduledThread"));

    // 定时执行一次的任务，延迟1s后执行
    executorService.schedule(new Runnable() {
        @Override
        public void run() {
            print("scheduleThreadPool");
            System.out.println(Thread.currentThread().getName() + ", delay 1s");
        }
    }, 1, TimeUnit.SECONDS);


    // 周期性地执行任务，延迟2s后，每3s一次地周期性执行任务
    executorService.scheduleAtFixedRate(new Runnable() {
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + ", every 3s");
        }
    }, 2, 3, TimeUnit.SECONDS);


    executorService.scheduleWithFixedDelay(new Runnable() {
        @Override
        public void run() {
            long start = new Date().getTime();
            System.out.println("scheduleWithFixedDelay 开始执行时间:" +
                    DateFormat.getTimeInstance().format(new Date()));
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            long end = new Date().getTime();
            System.out.println("scheduleWithFixedDelay执行花费时间=" + (end - start) / 1000 + "m");
            System.out.println("scheduleWithFixedDelay执行完成时间："
                    + DateFormat.getTimeInstance().format(new Date()));
            System.out.println("======================================");
        }
    }, 1, 2, TimeUnit.SECONDS);

}
```

# jion方法

一个线程调用jion方法，那么后面的代码必须等待这个线程执行完毕后才会执行

```java
public static void main(String[] args) throws Exception {

    Thread t1 = new Thread(() -> {

        for (int i = 1; i < 4; i++) {

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("线程A ： " + i);
        }
    });

    Thread t2 = new Thread(() -> {

        for (int i = 1; i < 4; i++) {

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("线程B ： " + i);
        }
    });

    t1.start();
    t2.start();

    t1.join();
    t2.join();

    System.out.println("爬取结束");
}
```



# 信号量

### Semaphore是什么

Semaphore也叫信号量，在JDK1.5被引入，可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。

Semaphore内部维护了一组虚拟的许可，许可的数量可以通过构造函数的参数指定。

- 访问特定资源前，必须使用acquire方法获得许可，如果许可数量为0，该线程则一直阻塞，直到有可用许可。
- 访问资源后，使用release释放许可。

Semaphore和ReentrantLock类似，获取许可有公平策略和非公平许可策略，默认情况下使用非公平策略。

### 应用场景

Semaphore可以用来做流量分流，特别是对公共资源有限的场景，比如数据库连接。
 假设有这个的需求，读取几万个文件的数据到数据库中，由于文件读取是IO密集型任务，可以启动几十个线程并发读取，但是数据库连接数只有10个，这时就必须控制最多只有10个线程能够拿到数据库连接进行操作。这个时候，就可以使用Semaphore做流量控制。



```java
public class SemaphoreTest {
    private static final int COUNT = 40;
    private static Executor executor = Executors.newFixedThreadPool(COUNT);
    private static Semaphore semaphore = new Semaphore(10);
    public static void main(String[] args) {
        for (int i=0; i< COUNT; i++) {
            executor.execute(new ThreadTest.Task());
        }
    }

    static class Task implements Runnable {
        @Override
        public void run() {
            try {
                //...读取文件操作
                semaphore.acquire();
                //...存数据过程
                semaphore.release();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
            }
        }
    }
}
```

# 线程池

newCachedThreadPool（可缓存的线程池）
newFixedThreadPool（固定大小的线程池）
newScheduledThreadPool（可做任务调度的线程池）
newSingleThreadPool（单个线程的线程池）
newWorkStealingPool（足够大小的线程池）

七大参数：
corePoolSize：线程池核心线程数量，核心线程不会被回收，即使没有任务执行，也会保持空闲状态。如果线程池中的线程少于此数目，则在执行任务时创建。
maximumPoolSize：池允许最大的线程数，当线程数量达到corePoolSize，且workQueue队列塞满任务了之后，继续创建线程。
keepAliveTime：超过corePoolSize之后的“临时线程”的存活时间。
unit：keepAliveTime的单位。
workQueue：当前线程数超过corePoolSize时，新的任务会处在等待状态，并存在workQueue中，BlockingQueue是一个先进先出的阻塞式队列实现，底层实现会涉及Java并发的AQS机制，有关于AQS的相关知识，我会单独写一篇，敬请期待。
threadFactory：创建线程的工厂类，通常我们会自顶一个threadFactory设置线程的名称，这样我们就可以知道线程是由哪个工厂类创建的，可以快速定位。
handler：线程池执行拒绝策略，当线数量达到maximumPoolSize大小，并且workQueue也已经塞满了任务的情况下，线程池会调用handler拒绝策略来处理请求。

# wait方法的使用前提

必须在同步代码块中使用

# 常用的Lock锁

ReentrantLock可重入锁，线程获取锁之后可以重复进入被锁住的代码

ReadWriteLock，可以单独为读写操作加锁，有读锁和写锁两种锁
