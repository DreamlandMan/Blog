## 缓存穿透与雪崩

#### 缓存穿透

- 大量请求缓存查不到，数据库压力太大
- **概念**：在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦**大量的请求数据**（例如秒杀场景）缓存都没有命中的话，就会全部转移到**数据库**上，造成数据库**极大的压力**，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为**洪水攻击**。

##### 解决方案

- **布隆过滤器**
  - 对所有可能查询的参数**以Hash的形式**存储，以便快速确定是否存在这个值，在控制层先进行**拦截校验**（校验参数的数据结构是否为Hash形式），校验不通过直接打回，减轻了存储系统的压力。
  - ![在这里插入图片描述](22.png)
- **缓存空对象**
  - 一次请求若在缓存和数据库中**都没找到**，就在**缓存**中放一个**空对象**用于处理后续这个请求。![在这里插入图片描述](23.png)
  - 这样做有一个缺陷：存储空对象也需要空间，大量的空对象会**耗费一定的空间**，存储效率并不高。解决这个缺陷的方式就是**设置较短过期时间**
  - 即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致（数据库有了数据，缓存还是空对象），这对于需要保持一致性的业务会有影响。

#### 缓存击穿

- 缓存过期，一个key被大量请求
- **概念**： 相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。
- 比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。

##### 解决方案

- **设置热点数据永不过期**
  - 这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会**占用空间**，一旦热点数据多了起来，就会占用部分空间。
- 加互斥锁(分布式锁)
  - 在访问key之前，采用**SETNX**（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。

#### 缓存雪崩

- **概念**：大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。
- 比如redis服务器断电、redis服务器被修冰箱师傅搬走了![在这里插入图片描述](24.png)

##### 解决方案

- redis高可用（集群）
  - 这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群
- 限流降级
  - 这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。
- 数据预热
  - 数据加热的含义就是在正式部署之前，我先把可能的数据先**预先访问**一遍，这样部分可能大量访问的数据就会**加载到缓存**中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。