#### List(列表)

- Redis列表是简单的**字符串列表**，按照插入顺序排序，**元素是非唯一的**。你可以添加一个元素到列表的头部（左边）或者尾部（右边）一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。

- 首先我们列表，可以经过规则定义将其变为**队列、栈、双端队列**等。列表可以**两端操作**，所以命令也就分为了LXXX和RXXX两类，有时候L也表示List例如LLEN。

  |                   命令                    |                             描述                             |                           追加描述                           |
  | :---------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
  |   **LPush/RPush key value1[value2..]**    |        从左边/右边向列表中**添加**值(一个或者多个)。         |                如果key不存在会创建一个新的key                |
  |    **LRange key startindex endindex**     |       **获取**list 起止坐标的元素（索引从左往右递增）        | 取值是先进后出的，就像入栈一样，栈底的最后才能拿到。闭区间，包含起止索引元素。**lrange key 0 -1**获取所有的元素 |
  |        **LPushX/RPushX key value**        |        向**已存在**的列表中**添加**值（一个或者多个）        |                                                              |
  | **LInsert key before\|after pivot value** |           在指定列表元素pivot的**前/后 插入**value           | （那栈作比喻）**after添加靠近栈底**那边，**before添加靠近栈顶**那边，最早添加的数据在栈底 |
  |               **LLen key**                |                       查看列表**长度**                       |                                                              |
  |           **LIndex key index**            |                   通过**索引获取**列表元素                   | 因为取值先进先出，所有索引**0是栈顶的元素**，是最后添加的元素<br />**-1是栈底的元素**，-2是栈底元素上面那个 |
  |         **LSet key index value**          |                  通过**索引**为元素**设值**                  |  索引0是最后添加的元素，index超出会报错，只能更新不能新增。  |
  |             **LPop/RPop key**             |       从最左边（栈顶）/最右边（栈底）**移除**值并返回        |                                                              |
  |         **LRem key count value**          | **count > 0**：从头部（**栈顶**）开始搜索，然后**删除**指定的value 至多删除count个 <br />**count < 0**：从尾部（**栈底**）开始搜索，然后**删除**指定的value 至多删除count个<br />**count = 0**：**删除**列表中**所有**的指定value。 |                                                              |
  |          **LTrim key start end**          | 通过下标**截取**指定范围内（start-end闭区间）的列表，没截到的部分删掉 |                                                              |
  |  **BLPop/BRPop key1 [key2...] timeout**   | **移出并获取**多个列表的第一个（栈顶）/最后一个（栈顶）指定元素， 如果列表**没有该元素**会**阻塞列表**直到**等待超时或发现可弹出元素**为止 | 阻塞到等待超时会返回(nil)，timeout是等待时间，单位为秒。<br />开一个新的客户端，为这个key添加数据可以解决阻塞 |
  |     **RPopLPush source destination**      | 将列表source的最尾部(右，栈顶）的值**弹出**，并返回，然后**加**到另一个列表destination的头部 |    相当于把删掉的值在另一个列表中备份，没有lpoprpush命令     |
  | **BRPopLPush source destination timeout** | 和**RPOPLPUSH**功能相同，如果列表**没有元素**会阻塞列表直到**等待超时或发现可弹出元素**为止。 |                                                              |
  
  **应用：**
  
  **消息排队！消息队列（Lpush Rpop）,栈（Lpush Lpop）**

实例

```shell
---------------------------LPUSH---RPUSH---LRANGE--------------------------------

127.0.0.1:6379> LPUSH mylist k1 # LPUSH mylist=>{1}
(integer) 1
127.0.0.1:6379> LPUSH mylist k2 # LPUSH mylist=>{2,1}
(integer) 2
127.0.0.1:6379> RPUSH mylist k3 # RPUSH mylist=>{2,1,3}
(integer) 3
127.0.0.1:6379> get mylist # 普通的get是无法获取list值的
(error) WRONGTYPE Operation against a key holding the wrong kind of value
127.0.0.1:6379> LRANGE mylist 0 4 # LRANGE 获取起止位置范围内的元素
1) "k2"
2) "k1"
3) "k3"
127.0.0.1:6379> LRANGE mylist 0 2
1) "k2"
2) "k1"
3) "k3"
127.0.0.1:6379> LRANGE mylist 0 1
1) "k2"
2) "k1"
127.0.0.1:6379> LRANGE mylist 0 -1 # 获取全部元素
1) "k2"
2) "k1"
3) "k3"

---------------------------LPUSHX---RPUSHX-----------------------------------

127.0.0.1:6379> LPUSHX list v1 # list不存在 LPUSHX失败
(integer) 0
127.0.0.1:6379> LPUSHX list v1 v2  
(integer) 0
127.0.0.1:6379> LPUSHX mylist k4 k5 # 向mylist中 左边 PUSH k4 k5
(integer) 5
127.0.0.1:6379> LRANGE mylist 0 -1
1) "k5"
2) "k4"
3) "k2"
4) "k1"
5) "k3"

---------------------------LINSERT--LLEN--LINDEX--LSET----------------------------

127.0.0.1:6379> LINSERT mylist after k2 ins_key1 # 在k2元素后 插入ins_key1
(integer) 6
127.0.0.1:6379> LRANGE mylist 0 -1
1) "k5"
2) "k4"
3) "k2"
4) "ins_key1"
5) "k1"
6) "k3"
127.0.0.1:6379> LLEN mylist # 查看mylist的长度
(integer) 6
127.0.0.1:6379> LINDEX mylist 3 # 获取下标为3的元素
"ins_key1"
127.0.0.1:6379> LINDEX mylist 0
"k5"
127.0.0.1:6379> LSET mylist 3 k6 # 将下标3的元素 set值为k6
OK
127.0.0.1:6379> LRANGE mylist 0 -1
1) "k5"
2) "k4"
3) "k2"
4) "k6"
5) "k1"
6) "k3"

---------------------------LPOP--RPOP--------------------------

127.0.0.1:6379> LPOP mylist # 左侧(头部)弹出
"k5"
127.0.0.1:6379> RPOP mylist # 右侧(尾部)弹出
"k3"

---------------------------RPOPLPUSH--------------------------

127.0.0.1:6379> LRANGE mylist 0 -1
1) "k4"
2) "k2"
3) "k6"
4) "k1"
127.0.0.1:6379> RPOPLPUSH mylist newlist # 将mylist的最后一个值(k1)弹出，加入到newlist的头部
"k1"
127.0.0.1:6379> LRANGE newlist 0 -1
1) "k1"
127.0.0.1:6379> LRANGE mylist 0 -1
1) "k4"
2) "k2"
3) "k6"

---------------------------LTRIM--------------------------

127.0.0.1:6379> LTRIM mylist 0 1 # 截取mylist中的 0~1部分
OK
127.0.0.1:6379> LRANGE mylist 0 -1
1) "k4"
2) "k2"

# 初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2
---------------------------LREM--------------------------

127.0.0.1:6379> LREM mylist 3 k2 # 从头部开始搜索 至多删除3个 k2
(integer) 3
# 删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2

127.0.0.1:6379> LREM mylist -2 k2 #从尾部开始搜索 至多删除2个 k2
(integer) 2
# 删除后：mylist: k2,k2,k2,k4,k2,k2


---------------------------BLPOP--BRPOP--------------------------

mylist: k2,k2,k2,k4,k2,k2
newlist: k1

127.0.0.1:6379> BLPOP newlist mylist 30 # 从newlist中弹出第一个值，mylist作为候选
1) "newlist" # 弹出
2) "k1"
127.0.0.1:6379> BLPOP newlist mylist 30
1) "mylist" # 由于newlist空了 从mylist中弹出
2) "k2"
127.0.0.1:6379> BLPOP newlist 30
(30.10s) # 超时了

127.0.0.1:6379> BLPOP newlist 30 # 我们连接另一个客户端向newlist中push了test, 阻塞被解决。
1) "newlist"
2) "test"
(12.54s)
```

