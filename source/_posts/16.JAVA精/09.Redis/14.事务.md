#### 事务

- Redis的单条命令是保证原子性的，但是redis事务不能保证原子性（要么同时成功，要么同时失败）

- Redis事务本质：一组命令的集合。

- 事务中每条命令都会被**序列化**，执行过程中**按顺序执行**，不允许其他命令进行干扰。

  - 一次性
  - 顺序性
  - 排他性

- Redis事务没有隔离级别的概念，不会出现幻读、脏读、不可重复读等等

- Redis单条命令是保证原子性的，但是事务不保证原子性！

  

#### Redis事务操作过程

- 开启事务（**multi**）

- 命令入队

- 执行事务（**exec**）|取消事务(**discard**)

- 事务执行后再取消会报错ERR DISCARD without MULTI，因为事务已经执行完毕不存在了，没有事务以供取消

- 事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成，取消事务(discard)所有命令都不执行。

  ```shell
  127.0.0.1:6379> MULTI #开启事务
  OK
  127.0.0.1:6379> set name hzc
  QUEUED
  127.0.0.1:6379> set age 13
  QUEUED
  127.0.0.1:6379> set sex 男
  QUEUED
  127.0.0.1:6379> exec #执行事务
  1) OK
  2) OK
  3) OK
  127.0.0.1:6379> get name #查看事务是否执行成功
  "hzc"
  
  #————————————————————————————
  127.0.0.1:6379> MULTI #开启事务
  OK
  127.0.0.1:6379> set name lb
  QUEUED
  127.0.0.1:6379> set age 16
  QUEUED
  127.0.0.1:6379> DISCARD #取消事务
  OK
  127.0.0.1:6379> get name #取消事务，命令并未执行
  "hzc"
  ```

  

#### 事务错误

- 代码语法错误（编译时异常）所有的命令都不执行

  ```shell
  127.0.0.1:6379> MULTI #开启事务
  OK
  127.0.0.1:6379> set name zs
  QUEUED
  127.0.0.1:6379> abaaba wycf #这是一条错误命令
  (error) ERR unknown command `abaaba`, with args beginning with: `wycf`, 
  127.0.0.1:6379> set age 20
  QUEUED
  127.0.0.1:6379> exec #执行事务
  (error) EXECABORT Transaction discarded because of previous errors.
  127.0.0.1:6379> get name
  "hzc"
  127.0.0.1:6379> get age #事务中所有命令都未执行
  "13"
  ```

- 代码逻辑错误 (运行时异常) **其他命令可以正常执行 **，错误命令抛出异常，不会回滚 >>> 所以不保证事务原子性

  ```shell
  127.0.0.1:6379> MULTI
  OK
  127.0.0.1:6379> set name zs
  QUEUED
  127.0.0.1:6379> set age haha
  QUEUED
  127.0.0.1:6379> incr age #因为age的值是字符串，所以这里有问题
  QUEUED
  127.0.0.1:6379> set son ls
  QUEUED
  127.0.0.1:6379> exec
  1) OK
  2) OK
  3) (error) ERR value is not an integer or out of range #逻辑错误
  4) OK
  127.0.0.1:6379> get name #其它命令执行成功了
  "zs"
  127.0.0.1:6379> get age
  "haha"
  127.0.0.1:6379> get son
  "ls"
  
  ```

  



#### 监控（面试常问）

- **悲观锁**

  - 很悲观，认为什么时候都会出现问题，无论做什么都会加锁，好比synchronized关键字

- **乐观锁**
  - 很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据
  - MySQL中是增加一个version字段，更新的时候比较version
  
- Redis使用**watch key**监控指定数据，相当于**乐观锁**加锁，**配合事务**使用，可以使用多个watch命令**监控多个key**。

  ```shell
  127.0.0.1:6379> set money 100 #设置当前持有金额
  OK
  127.0.0.1:6379> set out 0 #设置使用金额
  OK
  127.0.0.1:6379> watch money #监控money，为其加锁
  OK
  127.0.0.1:6379> MULTI #开启事务，花费20元，如果事务期间money未被改动，事务才能被正常执行
  OK
  127.0.0.1:6379> DECRBY money 20 #money-20
  QUEUED
  127.0.0.1:6379> INCRBY out 20 #out+20
  QUEUED
  127.0.0.1:6379> exec #比对监视的值，如果没有发生变化就执行事务
  1) (integer) 80
  2) (integer) 20
  
  #——————————————————————————————————————————
  127.0.0.1:6379> watch money #监控money
  OK
  127.0.0.1:6379> MULTI #开启事务，同时去另一个客户端执行命令DECRBY money 5，money-5。改out没关系，out没被监控
  OK
  127.0.0.1:6379> INCRBY out 20
  QUEUED
  127.0.0.1:6379> DECRBY money 20
  QUEUED
  127.0.0.1:6379> exec #被监控的数据被改变，执行失败
  (nil)
  
  ```

- 最好先解锁一下，然后再加锁进行事务，防止有些锁没解锁影响事务运行。**unwatch**进行解锁（只能解锁本客户端的）。

- **注意：每次提交执行exec后都会自动释放锁，不管是否成功**

  

