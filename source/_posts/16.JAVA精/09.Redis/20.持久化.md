## RDB

#### 什么是RDB

- 在主从复制中，rdb就是备用了。在从机上面。

- 在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ；![在这里插入图片描述](12.png)

- 默认情况下， Redis 将数据库快照保存在名字为 **dump.rdb**的二进制文件中，这个文件和redis-server同级。文件名可以在配置文件中进行自定义。

  ```
  dbfilename dump.rdb
  ```

#### 工作原理

- 在进行 RDB 的时候，redis 的主线程是不会做 io 操作的，主线程会 fork 一个**子线程**来完成该操作；
  - Redis 调用forks。同时拥有父进程和子进程。
  - 子进程将数据集写入到一个临时 RDB 文件中。
  - 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。
- **这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益**(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。)

#### 触发机制

- **save**规则（例如配置文件中的save 900 1）满足的情况下，会自动触发rdb原则，尽量使用默认的，不要瞎整
- 执行**flushall**命令，也会触发我们的rdb原则
- **退出redis**，也会自动产生rdb文件
- kill杀死进程不会报错，redis来不及

##### 理解

- 如果删掉dump.rdb，下次触发机制时会自动创建
- 如果停止redis后将dump.rdb删掉，下次开启服务将丢失数据
- 如果停止redis服务后，将另一个redis的dump.rdb放在当前redis启动目录（可以使用**config get dir**命令查看目录路径）下，重启服务可以同步另一个redis的数据
- 为了安全起见，生产环境中我们会将dump.rdb备份

##### save命令（Redis客户端）

- 使用 `save` 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了；
- 由于 `save` 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，`save`命令执行速度会非常慢，阻塞所有客户端的请求。![在这里插入图片描述](13.png)

##### flushall命令

- `flushall` 命令也会触发持久化 ；

##### 触发持久化规则

- 满足配置条件中的触发条件 ；比如save 900 1，900秒内至少一个key进行了修改就持久化![在这里插入图片描述](14.png)

##### bgsave

- `bgsave` 是异步进行，进行持久化的时候，`redis` 还可以将继续响应客户端请求 ；![在这里插入图片描述](15.png)

##### bgsave和save对比

| 命令   | save               | bgsave                             |
| ------ | ------------------ | ---------------------------------- |
| IO类型 | 同步               | 异步                               |
| 阻塞？ | 是                 | 是（阻塞发生在fock()，通常非常快） |
| 复杂度 | O(n)               | O(n)                               |
| 优点   | 不会消耗额外的内存 | 不阻塞客户端命令                   |
| 缺点   | 阻塞客户端命令     | 需要fock子进程，消耗内存           |

#### 优缺点

##### 优点：

1. 适合大规模的数据恢复
2. 对数据的完整性要求不高

##### 缺点：

1. 需要一定的时间间隔进行操作，如果最后一次持久化时redis意外宕机了，这个数据就丢失了。
2. fork进程的时候，会占用一定的内容空间。



## AOF

#### 什么是AOF

- 将我们所有的**写操作**命令都记录下来，默认每秒记录一次，默认保存到appendonly.aof文件（可以vim查看里面保存的命令），恢复的时候就把这个文件全部再执行一遍

-  快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。

- 如果要使用AOF，需要修改配置文件：

  ```shell
  appendonly yes
  ```

  - appendonly yes则表示启用AOF
  
  - 默认是不开启的，我们需要手动配置，然后重启redis，就可以生效了！
  
  - 如果这个aof文件有错误，这时候redis客户端是启动不起来的，会提示连接失败，需要修改这个aof文件
  
  - redis给我们提供了一个工具`redis-check-aof --fix appendonly.aof`（把错误的命令之后所有的命令直接删掉，如果错误比较前也可能会导致大量数据丢失），这个工具在redis-server的同级目录中，修复完重启redis服务
  
    ```shell
    [root@iZwz9dz9p8ei9h0gwdz6ohZ bin]# redis-check-aof --fix appendonly.aof 
    0x              51: Expected \r\n, got: 6475
    AOF analyzed: size=105, ok_up_to=55, diff=50
    This will shrink the AOF from 105 bytes, with 50 bytes, to 55 bytes
    Continue? [y/N]: y
    Successfully truncated AOF
    ```

#### 优点和缺点

##### 优点

1. 每一次修改都会同步，文件的完整性会更加好
2. 每秒同步一次，可能会丢失一秒的数据
3. 从不同步，效率最高

##### **缺点**

1. 相对于数据文件来说，aof远远大于rdb，修复速度比rdb慢！
2. aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化

#### 重写规则说明

```shell
#是否开启重启
no-appendfsync-on-rewrite no

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

- apf文件默认是无限追加的，文件会越来越大，如果文件大小超过64mb，同步时会fork一个新的进程来进行重写
- **重写**：如果一个key经过了多次操作，只保留key的最后状态，将这一系列繁琐的操作总结成一个命令，去除冗余让aof文件变得更小，默认不开启

## RDB和AOP选择

#### RDB 和 AOF 对比

|            | RDB    | AOF          |
| ---------- | ------ | ------------ |
| 启动优先级 | 低     | 高           |
| 体积       | 小     | 大           |
| 恢复速度   | 快     | 慢           |
| 数据安全性 | 丢数据 | 根据策略决定 |

#### 如何选择使用哪种持久化方式？

- 一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。

- 如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。

- 有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。





## 总结

- RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储
- AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协
  议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。
- 只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化
- 同时开启两种持久化方式
  - 在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB
    文件保存的数据集要完整。
  - RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合
    用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。
- 性能建议
  - 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条
    规则。
  - 如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的I0 ，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite 的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。
  - 如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave（主机/从机）同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。