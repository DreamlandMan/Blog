```java
@Configuration //相当于spring中的applicationContext.xml
public class ConfigBean {

//    注入RestTemplate
    @Bean
    @LoadBalanced //Ribbon,配置负载均衡实现ResTemplate
    public RestTemplate getRestTemplate(){
        return new RestTemplate();
    }

    /**
     * IRule:
     * RoundRobinRule 轮询策略
     * RandomRule 随机策略
     * AvailabilityFilteringRule ： 会先过滤掉，跳闸，访问故障的服务，避免404 null~，对剩下的进行轮询~
     * RetryRule ： 会先按照轮询获取服务~，如果服务获取失败，则会在指定的时间内进行，重试
     */
    //配置这个bean后SpringBoot会按照这个算法来进行负载均衡，myIRule这个名字不重要，什么都可以
    @Bean
    public IRule myIRule(){
        return new RandomRule();//使用随机策略
        //return new RoundRobinRule();//使用轮询策略
        //return new AvailabilityFilteringRule();//使用轮询策略
        //return new RetryRule();//使用轮询重试策略
    }
}
```

也可以自定义规则，在myRule包下自定义一个配置类MyRule.java，注意：**该包不要和主启动类所在的包同级，要跟启动类所在包同级**，防止被SpringBoot扫描到，被扫描到后所有服务都将共享该算法，放在外面可以单独为某服务配置算法，更灵活，比如说启动类是com.zi.springcloud.StartApp，那么配置类可以是com.zi.myrule.MyRule

- 注意，Ribbon负载均衡是在客户端，所以我们现在是在修改客户端代码

- 正常情况下，这个负载均衡算法配置不应该写在上面的ConfigBean里面，应该写到自定义配置类中

```java
/**
 * @Description: 自定义规则
 */
@Configuration
public class MyRule {
    @Bean
    public IRule myRule(){
        return new MyRandomRule();//默认是轮询RandomRule,现在自定义为自己的
    }
}
```

- RibbonClient注解，name属性值为服务名，

```java
//Ribbon 和 Eureka 整合以后，客户端可以直接调用，不用关心IP地址和端口号
@SpringBootApplication
@EnableEurekaClient
//在微服务启动的时候就能加载自定义的Ribbon类(自定义的规则会覆盖原有默认的规则)
@RibbonClient(name = "SPRINGCLOUD-PROVIDER-DEPT",configuration = MyRule.class)//开启负载均衡,并指定自定义的规则
public class DeptConsumer_80 {
    public static void main(String[] args) {
        SpringApplication.run(DeptConsumer_80.class, args);
    }
}
```

- 自定义的规则(这是复制RandomRule的代码改的)：MyRandomRule.java

  ```java
  import com.netflix.client.config.IClientConfig;
  import com.netflix.loadbalancer.AbstractLoadBalancerRule;
  import com.netflix.loadbalancer.ILoadBalancer;
  import com.netflix.loadbalancer.Server;
  import org.springframework.context.annotation.Configuration;
  import java.util.List;
  import java.util.concurrent.ThreadLocalRandom;
  
  @Configuration
  public class MyRule extends AbstractLoadBalancerRule {
      public MyRule() {
      }
  
      /**
       * 每个服务最多被访问3次，超过之后换下一个，也算是轮询算法
       * */
      private int count = 0;//当前服务被访问的次数
      private int index = 0;//默认访问的服务
      private int totalCount = 0;
  
      public Server choose(ILoadBalancer lb, Object key) {
          if (lb == null) {
              return null;
          } else {
              Server server = null;
  
              while(server == null) {
                  if (Thread.interrupted()) {
                      return null;
                  }
                  List<Server> upList = lb.getReachableServers();
                  List<Server> allList = lb.getAllServers();
                  int serverCount = allList.size();
                  if (serverCount == 0) {
                      return null;
                  }
  //算法开始---
                  /*int index = this.chooseRandomInt(serverCount);
                  server = (Server)upList.get(index);*/
                  if (count>=3){
                      count = 0;
                      if (index<allList.size()-1){
                          index++;
                      }else index = 0;
                  }
                  serverCount++;
                  count++;
                  server = upList.get(index);//uplist是活着的服务集合，server等于集合中哪个Server，就会访问哪个服务
                  System.out.println("第"+(totalCount++)+"次访问=>端口为："+server.getPort());
  //算法结束---
                  
                  if (server == null) {
                      Thread.yield();
                  } else {
                      if (server.isAlive()) {
                          return server;
                      }
  
                      server = null;
                      Thread.yield();
                  }
              }
              return server;
          }
      }
  
      /*protected int chooseRandomInt(int serverCount) {
          return ThreadLocalRandom.current().nextInt(serverCount);
      }*/
  
      public Server choose(Object key) {
          return this.choose(this.getLoadBalancer(), key);
      }
  
      public void initWithNiwsConfig(IClientConfig clientConfig) {
      }
  }
  ```

  