#### 服务降级

- ##### 什么是服务降级?

  - 服务降级是指 当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理，或换种简单的方式处理，从而释放服务器资源以保证核心业务正常运作或高效运作。说白了，**就是尽可能的把系统资源让给优先级高的服务**。

  - 资源有限，而请求是无限的。如果在并发高峰期，不做服务降级处理，一方面肯定会影响整体服务的性能，严重的话可能会导致宕机某些重要的服务不可用。所以，一般在高峰期，为了保证核心功能服务的可用性，都要对某些服务降级处理。比如当双11活动时，把交易无关的服务统统降级，如查看蚂蚁森林，查看历史订单等等。

  - 服务降级主要用于什么场景呢？当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，可以将一些 不重要 或 不紧急 的服务或任务进行服务的 延迟使用 或 暂停使用。

  - 降级的方式可以根据业务来，可以延迟服务，比如延迟给用户增加积分，只是放到一个缓存中，等服务平稳之后再执行 ；或者在粒度范围内关闭服务，比如关闭相关文章的推荐。![在这里插入图片描述](hystrix7.png)

  - 由上图可得，**当某一时间内服务A的访问量暴增，而B和C的访问量较少，为了缓解A服务的压力，这时候需要B和C暂时关闭一些服务功能，去承担A的部分服务，从而为A分担压力，叫做服务降级**。

  - 负载均衡作用于不同服务器的相同服务，服务降级作用于不同服务

  - 服务熔断是当一个方法失效时采用备用方法，服务降级是在服务关闭时采用备用服务（重写的Service），降级也是熔断的一种策略，算批量熔断

  - 生产者服务方报错就**熔断**，因为生产者还在，所以写在**生产者模块**

  - 生产者服务方被关闭了就**降级**，因为生产者不存在了，所以写在**消费者模块**

  - 熔断是应对报错的，降级是应对高并发的

  - 降级案例

    - 因为消费者模块引入了api模块，所以在api模块的service包中创建一个类实现FallbackFactory接口，重写create方法，返回值是服务的service类

    ```java
    //降级
    @Component
    public class DeptClientServiceCallbackFactory implements FallbackFactory {
    
    //    如果服务降级了，就不会调用正常的DeptClientService接口的方法，而是调用自定义重写的接口的方法
        @Override
        public DeptClientService create(Throwable throwable) {
            return new DeptClientService() {
                @Override
                public Dept queryById(Long id) {
                    return new Dept().setDeptno(id)
                            .setDname("这个id没有对应的信息，该服务已关闭，客户端提供了降级信息")
                            .setDb_source("No Data");
                }
    
                @Override
                public List<Dept> queryAll() {
                    return null;
                }
    
                @Override
                public boolean add(Dept dept) {
                    return false;
                }
            };
        }
    }
    ```

    - 将FallbackFactory接口实现类与service接口相关联，使该service接口降级后调用FallbackFactory接口实现类

      ```java
      @Component
      @FeignClient(name = "SPRING-CLOUD-PROVIDER",fallbackFactory = DeptClientServiceCallbackFactory.class)
      public interface DeptClientService {
          @GetMapping("/dept/query{id}")
          Dept queryById(@PathVariable("id") Long id);
          @GetMapping("/dept/queryAll")
          List<Dept> queryAll();
          @GetMapping("/dept/add")
          boolean add(Dept dept);
      }
      ```

      - application.yml配置开启降级，必须开启这个配置，不然feign和hystrix不能共存

        ```yml
        #降级
        feign:
          hystrix:
            enabled: true #开启降级
        ```

#### 服务熔断和降级的区别

- **服务熔断—>服务端**：某个服务超时或异常，引起熔断~，类似于保险丝(自我熔断)
- **服务降级—>客户端**：从整体网站请求负载考虑，当某个服务熔断或者关闭之后，服务将不再被调用，此时在客户端，我们可以准备一个 FallBackFactory ，返回一个默认的值(缺省值)。会导致整体的服务下降，但是好歹能用，比直接挂掉强。
- 触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）
- 实现方式不太一样，服务降级具有代码侵入性(由控制器完成/或自动降级)，熔断一般称为**自我熔断**。



