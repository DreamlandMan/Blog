# 后端

## 导入依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-websocket</artifactId>
    <version>2.2.0.RELEASE</version>
</dependency>
```

## 配置WebSocket核心类

### 思路

- 链接参数需要收信人和收信人的UID，方便后面发送消息
- @Open方法：
  - 用户连接websocket时将session存进一个静态的ConcurrentHashMap类型sessionMap中，键为用户的UID，值为session，不能重复存入，这个集合相对于HashMap是线程安全的
- @OnClose方法：
  - 用户断开连接（关闭网页或者关闭浏览器）后，从sessionMap中移除键为用户UID的元素
- @OnMessage：
  - 当前端向后端发送消息时会自动调用，message是消息内容。
  - 通过`Long.parseLong(session.getRequestParameterMap().get("UID").get(0))`可以获取链接上的收信人UID参数，通过这个UID从sessionMap中获取收信人的session，通过这个session将message发送给这个用户的客户端
  - 如果sessionMap中没有这个用户则进行其它操作，比如说将聊天记录存进数据库，下次收信人连接websocket调用@Open时读取数据库发送给收信人客户端
  - `session.getBasicRemote().sendText(message)`：使用该session向其所属用户发送消息
- 因为这里不能使用@Autowried注解自动装配（也许是因为@Component注解），所以使用`SpringContextUtil.getBean("xxx")`手动注入，SpringContextUtil是自定义的工具类，后面有源码。
- 一个ws链接中包含发信人和收信人UID

```java
package com.hzc.barter.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import javax.websocket.OnClose;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.ServerEndpoint;
import java.util.concurrent.ConcurrentHashMap;

/**
 *  设置访问的URL
 *  UID为发信人的UID
 *  TOUID为收信人的UID
 *  */
@Component
@ServerEndpoint("/websocket/{UID}/{TOUID}")
@Slf4j
public class WebSocket {

    private Session session;
    private ConcurrentHashMap<Long,Session> sessionMap = new ConcurrentHashMap<>();

    /**
     * 连接WebSocket，连接之前需要先初始化设置登录用户
     * @Param session 发送消息用得上
     * @Param userId 用户UID
     * @Param sessionId 数据表session_list的中主键，该表用于存两个用户之间的会话
     * */
    @OnOpen
    public void onOpen(Session session
            /*, @PathParam("UID") Long uid, @PathParam("TOUID") Long touid,
            ,@PathParam("sessionId")  String sessionId*/){
        this.session = session;
        long uid = Long.parseLong(session.getRequestParameterMap().get("UID").get(0));
        sessionMap.put(uid,session);
    }

    @OnClose
    public void onClose(){
        Long userId = Long.parseLong(session.getRequestParameterMap().get("UID").get(0));
        System.out.println(userId+"=================close=================");
        if (userId!=null) sessionMap.remove(userId);
        else log.error("从sessionMap中移除用户的session失败，userId为null");
    }

    @OnMessage
    public void onMessage(String message){
        Long uid = Long.parseLong(session.getRequestParameterMap().get("UID").get(0));
        Long touid = Long.parseLong(session.getRequestParameterMap().get("TOUID").get(0));
        System.out.println(uid+"--->"+touid+"：["+message+"]");
        sendTextMessage(touid,message);
    }

     /**
      * 此为单点消息 (发送文本)
      * 通过连接中的userId获取指定用户的session
      * 通过该用户的session像该用户发送消息
      */
    public void sendTextMessage(Long userId, String message) {
        //群发
        /*for (Map.Entry<Long, Session> entry : SessionPool.sessionMap.entrySet()) {
            Session value = entry.getValue();
            try {
                value.getBasicRemote().sendText(message);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }*/
        //私聊
        Session session = sessionMap.get(userId);
        if (session != null) {
            try {
                session.getBasicRemote().sendText(message);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }else {
            System.out.println("对方未登录");
        }
    }
}
```

## SpringContextUtil

```java
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

/**
 * 获取spring中的bean对象工具类
 * @date 2018-07-23 17:42
 */
@Component
public class SpringContextUtil  implements ApplicationContextAware {

    /**
     *  Spring应用上下文环境
     */
    private static ApplicationContext applicationContext;


    /**
     * 实现ApplicationContextAware接口的回调方法，设置上下文环境
     */
    @Override
    public void setApplicationContext(ApplicationContext applicationContext)
            throws BeansException {
        SpringContextUtil.applicationContext = applicationContext;
    }

    public static ApplicationContext getApplicationContext() {
        return applicationContext;
    }

    /**
     * 获取对象 这里重写了bean方法，起主要作用
     */
    public static Object getBean(String beanId) throws BeansException {
        return applicationContext.getBean(beanId);
    }
}

```

## 控制器调用登录模块（不用看）

```java
import com.alibaba.fastjson.JSON;
import com.hzc.barter.pojo.Dto;
import com.hzc.barter.pojo.user.User;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanWrapperImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpSession;
import java.lang.reflect.Method;

@RestController
@Api(tags = "注入登录用户")
@RequestMapping("/login")
@Slf4j
public class LoginController {
    @Autowired
    private User loggingUser;
    @Autowired
    private Dto dto;

    @PostMapping("/setLoggingUser")
    @ApiOperation("注入登录用户")
    public String setLoggingUser(HttpSession session){
        User user = (User) session.getAttribute("user");

        dto.setData(null).setCode(null).setMsg(null);

        if (user == null)
            return JSON.toJSONString(dto.setCode(500).setMsg("用户登录状态超时，请重新登录"));
        else {
            Method[] methods = user.getClass().getMethods();
            try {
                //获取User类的所有方法
                for (Method method : methods) {
                    //判断这个方法是不是get方法
                    if (method.getName().contains("get")){
                        //如果user对象使用这个get方法取值不为null
                        if (method.invoke(user)!=null){
                            // 再遍历一次User方法
                            for (Method m : methods) {
                                //如果这个方法是上面get方法对应的set方法
                                if (m.getName().equals(method.getName().replace("get","set"))){
                                    // 那么loggingUser调用该set方法，把user对象调用get方法的值传进来
                                    m.invoke(loggingUser,method.invoke(user));
                                    break;
                                }
                            }
                        }
                    }
                }
                return JSON.toJSONString(dto.setCode(200).setMsg("登录用户同步成功"));
            }catch (Exception e){
                log.error("聊天模块初始化登录用户失败，反射->{}",e.getMessage());
                return JSON.toJSONString(dto.setCode(500).setMsg("登录用户同步出错"));
            }
        }
    }
}

```

## 因为跨模块获取用户登录信息，需要配置session共享（不用看）

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;

@Configuration
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 86400*30)
public class SessionConfig {
}
```

## 因为前后端分离，需要配置跨域

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 配置跨域
 * */
@Configuration
public class CrosConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        //配置 可以访问的地址 /**，所有
        registry.addMapping("/**")
                // * 表示对所有的地址都可以访问
                .allowedOrigins("*")
                //  跨域的请求头
                .allowedHeaders("*")
                //  跨域的请求方法
                .allowedMethods("POST","GET","PUT","DELETE")
                //加上了这一句，大致意思是是否可以携带 cookie
                //最终的结果是不可以 在跨域请求的时候不能获取同一个 session
                .allowCredentials(false)
                .maxAge(3600);
    }
}

```



# 前端

```vue
<template>
  <div class="home">
    <h1>Chat</h1>
    <el-input v-model="UID" placeholder="1、本人UID"></el-input>
    <el-input v-model="TOUID" placeholder="2、收信人UID"></el-input>
    <el-button @click="initWebsocket">3、连接</el-button>
    <el-input v-model="message" placeholder="4、消息内容"></el-input>
    <el-button @click="sendMsg">5、发送</el-button>
    <el-input disabled placeholder="聊天内容">{{inputContext}}</el-input>
    <textarea disabled placeholder="聊天内容"
    style="width: 100%">{{areaContext}}</textarea>
  </div>
</template>

<script>

export default {
  name: 'Home',
  data(){
    return{
      UID:'',
      TOUID:'',
      message:'',
      chat:'',
      inputContext:'',
      areaContext:'',
      // 因为局域网IP总会变，所以提取出来
      port:"192.168.76.219"
    }
  },
  created() {
  },
  methods: {
    initWebsocket: function(){
      console.log("init")
      // WebSocket与普通的请求所用协议有所不同，ws等同于http，wss等同于https
      //  ws链接中包含发信人和收信人UID
      this.websock = new WebSocket("ws://"+this.port+":8005/websocket/"+this.UID+"/"+this.TOUID);
      this.websock.onopen = this.websocketonopen;
      this.websock.onerror = this.websocketonerror;
      this.websock.onmessage = this.websocketonmessage;
      this.websock.onclose = this.websocketclose;
    },
    websocketonopen: function () {
      console.log("WebSocket连接成功");
      alert("WebSocket连接成功");
    },
    websocketonerror: function (e) {
      console.log("WebSocket连接发生错误",e);
      alert("WebSocket连接发生错误");
    },
    websocketonmessage: function (msg){
      // let  data = JSON.parse(msg.data)
      this.chat += msg.data
      this.inputContext+="对方："+msg.data+' '
      this.areaContext+="对方："+msg.data+'\n'
    },
    websocketclose: function (e){
      //校正登录的用户到loggingUser对象，防止关闭服务混乱
      console.log("关闭成功")
      alert("关闭成功")
    },
    sendMsg(){
      this.websock.send(this.message)
      this.inputContext+="我："+this.message+' '
      this.areaContext+="我："+this.message+'\n'
      this.message = ''
    },
    setLoggingUser(){
      axios.post("http://"+this.port+":8005/login/setLoggingUser")
          .then(function (d){
            console.log(d)
          })
    }
  }
}
</script>
```

## 报错

```
localhost/:1  Access to XMLHttpRequest at 'http://localhost:8005/login/setLoggingUser' from origin 'http://localhost:8080' has been blocked by CORS policy: The value of the 'Access-Control-Allow-Origin' header in the response must not be the wildcard '*' when the request's credentials mode is 'include'. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.
```

## setLoggingUser访问失败，因为axios默认请求不会带cookie/session

```javascript
setLoggingUser(){
      axios.defaults.withCredentials = true
      axios.post("http://"+this.port+":8005/login/setLoggingUser")
    		//使用钩子函数代替function，因为function中this的作用域变了
          .then((d)=>{
            console.log(d)
            this.initWebsocket()
          })
    }
```

## 相应的后端接口请求体也需要同意其携带session

```java
@CrossOrigin(allowCredentials = "true")
public String setLoggingUser(HttpSession session){
    ...
}
```

# 问题

- 连接报错：`The WebSocket session [5] has been closed and no method (apart from close()) may be called on a closed session`，连接被关闭了，混乱导致误关吗