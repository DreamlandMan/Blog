## 导入依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <scope>test</scope>
</dependency>

<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>
```

## 创建JWT工具类

模仿上一篇标记的测试类，创建静态的工具类方法

```java
import io.jsonwebtoken.*;

import java.util.Date;
import java.util.UUID;

public class JwtUtil {
    //一天的毫秒数
    private static long dayMillis = 1000*60*60*24;
    //签名密钥
    private static String signature = "admin";

    public static String jwt(String username,String role) {
        JwtBuilder jwtBuilder = Jwts.builder();
        String jwtToken = jwtBuilder
            //jwt的id
            .setId(UUID.randomUUID().toString())
            //签名
            .setSubject("admin-test")
            //有效时间，到何时到期，现在的毫秒数加上一天的毫秒数
            .setExpiration(new Date(System.currentTimeMillis()+dayMillis))
            //头部分
            .setHeaderParam("typ","JWT")
            .setHeaderParam("alg","HS256")
            //载荷部分
            .claim("username",username)
            .claim("role",role)
            //签名，signature，以指定密钥用ES256编码对签名加密
            .signWith(SignatureAlgorithm.HS256,signature)
            //将jwt三部分拼接
            .compact();
        return jwtToken;
    }

    public static Claims parse(String token){
        JwtParser jwtParser = Jwts.parser();
        Jws<Claims> claimsJws = jwtParser
            //指定解密密钥，不需要设置解密编码，因为header中的alg指定了
            .setSigningKey(signature)
            //取出token的数据，它会返回一个类似集合的对象
            .parseClaimsJws(token);
        //获取token数据
        Claims body = claimsJws.getBody();

        return body;
    }
    //看看解析能不能成功，不能成功代表不合法
    public static boolean checkToken(String token){
        if (token==null)return false;
        try {
            Jws<Claims> claimsJws = Jwts.parser().setSigningKey(signature).parseClaimsJws(token);
        }catch (Exception e){
            return false;
        }
        return true;
    }
}

```

## 创建用户POJO类

```java
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.Accessors;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Accessors(chain = true)
public class User {
    private String username;
    private String role;
    private String token;
}

```

## 创建登录接口

```java
import com.example.demo.entity.User;
import com.example.demo.utils.JwtUtil;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class LoginController {
    //这里就不从数据库取数据了，直接定义好
    public static String USERNAME = "张三";
    public static String ROLE = "admin";

    @GetMapping("/login")
    public User login(String username,String role){
        if (USERNAME.equals(username)&&ROLE.equals(role)){
            User user = new User().setUsername(username).setRole(role);
            user.setToken(JwtUtil.jwt(username,role));
            return user;
        }
        return null;
    }
}

```

## 解决跨域问题

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * 配置跨域
 * */
@Configuration
public class CrosConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        //配置 可以访问的地址 /**，所有
        registry.addMapping("/**")
            // * 表示对所有的地址都可以访问
            .allowedOrigins("*")
            //  跨域的请求头
            .allowedHeaders("*")
            //  跨域的请求方法
            .allowedMethods("POST","GET","PUT","DELETE")
            //加上了这一句，大致意思是是否可以携带 cookie
            //最终的结果是不可以 在跨域请求的时候不能获取同一个 session
            .allowCredentials(false)
            .maxAge(3600);
    }
}
```

## 前端页面

### 登录页面

通过axios请求登录接口，返回user对象

```vue
<template>
<div class="login-container">
    <el-form :model="ruleForm" :rules="rules"
             status-icon
             ref="ruleForm"
             label-position="left"
             label-width="0px"
             class="demo-ruleForm login-page">
        <h3 class="title">系统登录</h3>
        <el-form-item prop="username">
            <el-input type="text"
                      v-model="ruleForm.username"
                      auto-complete="off"
                      placeholder="用户名"
                      ></el-input>
    </el-form-item>
        <el-form-item prop="password">
            <el-input type="password"
                      v-model="ruleForm.role"
                      auto-complete="off"
                      placeholder="权限"
                      ></el-input>
    </el-form-item>
        <el-form-item style="width:100%;">
            <el-button type="primary" style="width:100%;" @click="handleSubmit" >登录</el-button>
    </el-form-item>
    </el-form>
    </div>
</template>

<script>
    export default {
        name: "Login",
        data(){
            return{
                ruleForm: {
                    username: '张三',
                    role: ''
                },
                rules: {
                    username: [{required: true, message: '请输入用户名', trigger: 'blur'}],
                    password: [{required: true, message: '请输入权限', trigger: 'blur'}]
                }
            }
        },
        methods: {
            handleSubmit(){
                this.$refs.ruleForm.validate((valid) => {
                    if(valid){
                        let _this = this
                        axios.get('http://localhost:8081/login',{params:_this.ruleForm}).then(function (response) {
                            //如果返回的数据不为null代表登录成功
                            if(response.data!=null){
                                //将返回的user对象以字符串形式存储起来
                                localStorage.setItem('access-admin',JSON.stringify(response.data))
                                //跳转到首页
                                _this.$router.replace({path:'/'})
                            }
                        }).catch(function (e){
                            console.log(e)
                        })
                    }else{
                        console.log('error submit!');
                        return false;
                    }
                })
            }
        }
    };
</script>

<style scoped>
    .login-container {
        width: 100%;
        height: 100%;
    }
    .login-page {
        -webkit-border-radius: 5px;
        border-radius: 5px;
        margin: 180px auto;
        width: 350px;
        padding: 35px 35px 15px;
        background: #fff;
        border: 1px solid #eaeaea;
        box-shadow: 0 0 25px #cac6c6;
    }
    label.el-checkbox.rememberme {
        margin: 0px 0px 15px;
        text-align: left;
    }
</style>
```

### 首页

```vue
<template>
<div class="home">
    欢迎回来！{{admin.username}}
    <div id="nav">
        <router-link to="/about">下载</router-link>
    </div>
    <h1>这是首页</h1>
    </div>
</template>

<script>

    export default {
        data(){
            return {
                admin: ''
            }
        },
        created() {
            //获取用户登录信息，将用户名现实中首页
            this.admin = JSON.parse(window.localStorage.getItem('access-admin'))
        }
    }
</script>
```

### 修改roter文件夹中index.js

修改路由

创建router.beforeEach方法，每次跳转路由先执行该方法，相当于后端的拦截器

```js
import Vue from 'vue'
import VueRouter from 'vue-router'
import Home from '../views/Home.vue'
import Login from "../views/Login"
import Error from "../views/Error";

Vue.use(VueRouter)

const routes = [
    {
        path: '/',
        name: 'Home',
        component: Home
    },
    {
        path: '/about',
        name: 'About',
        // route level code-splitting
        // this generates a separate chunk (about.[hash].js) for this route
        // which is lazy-loaded when the route is visited.
        component: () => import(/* webpackChunkName: "about" */ '../views/About.vue')
    },
    {
        path: '/login',
        name: 'Login',
        component: Login
    },
    {
        path: '/error',
        name: 'Error',
        component: Error
    }
]

const router = new VueRouter({
    mode: 'history',
    base: process.env.BASE_URL,
    routes
})

router.beforeEach((to, from, next) => {
	//如果页面是否是登录页面，如果是就清除旧的access-admin
    if (to.path.startsWith('/login')) {
        window.localStorage.removeItem('access-admin')
        next()
    } else {
        //如果不是登录页面，代表已经登录过了，就从access-admin中取登录信息
        let admin = JSON.parse(window.localStorage.getItem('access-admin'))
        //如果没有登录信息，就跳转登录页面
        if (!admin) {
            next({path: '/login'})
        } else {
            //如果有登录信息就验证token是否合法
            //校验token合法性
            axios({
                url:'http://localhost:8081/checkToken',
                method:'get',
                headers:{
                    token:admin.token
                }
            }).then((response) => {
                console.log(response.data)
                if(!response.data){
                    console.log('校验失败')
                    next({path: '/error'})
                }
            })
            next()
        }
    }
})

export default router
```

### error页面

```vue
<template>

</template>

<script>
    export default {
        name: "Error",
        created() {
            let _this = this
            this.$alert('登录信息失效！', '提示', {
                confirmButtonText: '确定'
            }).then((response) => {
                //移除旧登录信息然后跳转登录
                localStorage.removeItem('access-admin')
                _this.$router.replace({path: '/login'})
            })
        }
    }
</script>

<style scoped>

</style>
```

## 后端token校验接口

```java
@GetMapping("checkToken")
public Boolean checkToken(HttpServletRequest request){
    String token = request.getHeader("token");
    return JwtUtil.checkToken(token);
}
```

