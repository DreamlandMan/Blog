## SpringBoot使用AOP(针对注解)

### AOP简介

AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术

AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。

AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。

AOP是一个概念，并没有设定具体语言的实现，它能克服那些只有单继承特性语言的缺点，spring2.0之后整合AspectJ第三方AOP技术。

AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法所以它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。

### 主要功能

日志记录、事务处理、性能统计、安全控制、异常处理、缓存处理、持久化操作、资源池等

### 主要意图

将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码

### AOP与OOP区别

OOP（面向对象编程）针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。

AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。这两种设计思想在目标上有着本质的差异。

### AOP相关术语

目标对象target

- 需要被增强的对象，由于spring aop是通过代理模式实现，从而这个对象永远是被代理对象。

连接点(join point)

- 指那些被拦截到的点，在spring中这些点指的是方法，因为spring只支持方法类型的连接点,(被增强类中的方法[要不要增强不一定,但是都可以增强])

切入点(pointcut)

- 表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，
-    它定义了相应的 Advice 将要发生的地方简单说切入点是指我们要对哪些连接点进行拦截的定义,(已配置,被增强类中的方法[执行增强的连接点])

通知(advice)

-    指拦截到连接点之后所要做的事情就是通知，通知分为前置通知，后置通知，异常通知，最终通知，环绕通知.(增强的代码)

引入introduction

-    引介是一种特殊的通知，在不修改类代码的前提下，introduction可以在运行期为类动态地添加一些方法或属性

切面aspect

- 是切入点和通知的结合

织入weaving

-    织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期，类装载期，运行期进行。
-    Spring采用动态织入，而aspectj采用静态织入

代理Proxy

-    一个类被AOP织入增强后，就产生一个结果代理类

### AOP底层实现

AOP分为静态AOP和动态AOP。静态AOP是指AspectJ实现的AOP，他是将切面代码直接编译到Java类文件中。动态AOP是指将切面代码进行动态织入实现的AOP。

Spring的AOP为动态AOP，实现的技术为： JDK提供的动态代理技术 和 CGLIB(动态字节码增强技术)

### 传统的spring aop开发中它支持增强(advice)有五种:

前置通知 目标方法执行前增强 org.springframework.aop.MethodBeforeAdvice

后置通知 目标方法执行后增强 org.springframework.aop.AfterReturningAdvice

环绕通知 目标方法执行前后进行增强 org.aopalliance.intercept.MethodInterceptor

异常抛出通知 目标方法抛出异常后的增强 org.springframework.aop.ThrowsAdvice

引入通知 在目标类中添加一些新的方法或属性

## SpringBoot中使用AOP

1、在pom文件中加入AOP依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
    <version>2.1.7.RELEASE</version>
</dependency>

<!-- 如果导入了web依赖就不需要导入aop依赖了，因为web依赖的webmvc依赖中有aop依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

2、新建一个切面类

```java
/**
 * @Description
 * 其中：
 * * @Aspect 表明是一个切面类
 * * @Component 将当前类注入到Spring容器内
 * * @Pointcut 切入点，其中execution用于使用切面的连接点。使用方法：execution(方法修饰符(可选) 返回类型 方法名 参数 异常模式(可选)) ，可以使用通配符匹配字符，*可以匹配任意字符。
 * * @Before 在方法前执行
 * * @After 在方法后执行
 * * @AfterReturning 在方法执行后返回一个结果后执行
 * * @AfterThrowing 在方法执行过程中抛出异常的时候执行
 * * @Around 环绕通知，就是可以在执行前后都使用，这个方法参数必须为ProceedingJoinPoint，proceed()方法就是被切面的方法，上面四个方法可以使用JoinPoint，JoinPoint包含了类名，被切面的方法名，参数等信息。
 * @Author 
 * @Version V1.0.0
 * @Since 1.0
 * @Date 2019-09-25
 */
@Aspect
@Component
public class IndexAspect {

    @Pointcut("execution(public * com.mmz.springboot.controller.aop.aopannotation.*.*(..))")
    public void LogAspect(){}

    @Before("LogAspect()")
    public void doBefore(JoinPoint joinPoint){
        System.out.println("doBefore");
    }

    @After("LogAspect()")
    public void doAfter(JoinPoint joinPoint){
        System.out.println("doAfter");
    }

    @AfterReturning("LogAspect()")
    public void doAfterReturning(JoinPoint joinPoint){
        System.out.println("doAfterReturning");
    }

    @AfterThrowing("LogAspect()")
    public void deAfterThrowing(JoinPoint joinPoint){
        System.out.println("deAfterThrowing");
    }

    @Around("LogAspect()")
    public Object deAround(ProceedingJoinPoint joinPoint) throws Throwable{
        System.out.println("deAround");
        return joinPoint.proceed();
    }
}
```

3、利用自定义注解使用AOP

```java
/**
 * 新建自定义注解，新建注解与新建接口类似，将interface改为@interface即可。
 */
@Target({ElementType.METHOD, ElementType.TYPE}) //定义注解修饰的目标,方法/类
@Retention(RetentionPolicy.RUNTIME) //定义注解的生命周期(SOURCE源码级别,CLASS编译期级别,RUNTIME运行期级别)
public @interface DoneTime{
    String param() default "";
}
```

4、创建自定义注解对应切面(在使用注解的地方，利用环绕通知可做进一步的逻辑处理 )

```java
/**
 * @Description  创建自定义注解对应切面
 * @Author zhoumm
 * @Version V1.0.0
 * @Since 1.0
 * @Date 2019-09-25
 */

@Aspect
@Component
public class DoneTimeAspect {
    @Around("@annotation(doneTime)")  //对指定注解使用环绕通知
    public Object around(ProceedingJoinPoint joinPoint, DoneTime doneTime) throws Throwable {
        System.out.println("方法开始时间是:"+new Date());
        Object o = joinPoint.proceed();
        System.out.println("方法结束时间是:"+new Date()) ;
        return o;
    }
}
```

5、创建一个IndexController进行测试 （两个接口进行效果对比）

```java
/**
 * @Description
 * @Author 
 * @Version V1.0.0
 * @Since 1.0
 * @Date 2019-09-25
 */

@Api(value = "aop", description = "aop测试样例文档")
@RestController
@RequestMapping("/aop")
@Slf4j
@Validated
public class IndexController {

    @GetMapping("/index")
    @DoneTime(param = "IndexController")
    public String index(){
        System.out.println("方法执行");
        return "hello guodegang";
    }

    @GetMapping("/index2")
    public String index2(){
        System.out.println("方法2执行");
        return "hello yuqian";
    }
}
```

6、浏览器访问 http://localhost:8787/aop/index1，控制台如下：

```
方法开始时间是:Wed Sep 25 17:16:02 CST 2019
deAround
doBefore
方法执行
doAfter
doAfterReturning
方法结束时间是:Wed Sep 25 17:16:02 CST 2019
```

7、浏览器访问 http://localhost:8787/aop/index2，控制台如下：

```text
deAround
doBefore
方法2执行
doAfter
doAfterReturning
```

## 拓展：AspectJ的切入点表达式---execution表达式详解

### Aspectj切入点语法定义

在使用spring框架配置AOP的时候，不管是通过XML配置文件还是注解的方式都需要定义pointcut”切入点”

例如定义切入点表达式 execution (* com.sample.service.impl..*. *(..))

execution()是最常用的切点函数，其语法如下所示：

整个表达式可以分为五个部分：

1、execution()：表达式主体。

2、第一个*号：表示返回类型， *号表示所有的类型。

3、包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，com.sample.service.impl包、子孙包下所有类的方法。

4、第二个\*号：表示类名，\*号表示所有的类。

5、\*(..):最后这个星号表示方法名，\*号表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数

### AspectJ的Execution表达式

execution()

execution()是最常用的切点函数，其语法如下所示：

execution(<修饰符模式>? <返回类型模式> <方法名模式>(<参数模式>) <异常模式>?) 除了返回类型模式、方法名模式和参数模式外，其它项都是可选的。与其直接讲解该方法的使用规则，还不如通过一个个具体的例子进行理解。下面，我们给出各种使用execution()函数实例。

1)通过方法签名定义切点

execution(public * *(..))l

匹配所有目标类的public方法，但不匹配SmartSeller和protected void showGoods()方法。第一个*代表返回类型，第二个*代表方法名，而..代表任意入参的方法；

execution(* *To(..))l

匹配目标类所有以To为后缀的方法。它匹配NaiveWaiter和NaughtyWaiter的greetTo()和serveTo()方法。第一个*代表返回类型，而*To代表任意以To为后缀的方法；

2)通过类定义切点

execution(* com.baobaotao.Waiter.*(..))l

匹配Waiter接口的所有方法，它匹配NaiveWaiter和NaughtyWaiter类的greetTo()和serveTo()方法。第一个*代表返回任意类型，com.baobaotao.Waiter.*代表Waiter接口中的所有方法；

execution(* com.baobaotao.Waiter+.*(..))l

匹 配Waiter接口及其所有实现类的方法，它不但匹配NaiveWaiter和NaughtyWaiter类的greetTo()和serveTo()这 两个Waiter接口定义的方法，同时还匹配NaiveWaiter#smile()和NaughtyWaiter#joke()这两个不在Waiter 接口中定义的方法。

3)通过类包定义切点

在类名模式串中，“.*”表示包下的所有类，而“..*”表示包、子孙包下的所有类。

execution(* com.baobaotao.*(..))l

匹配com.baobaotao包下所有类的所有方法；

execution(* com.baobaotao..*(..))l

匹 配com.baobaotao包、子孙包下所有类的所有方法，如com.baobaotao.dao，com.baobaotao.servier以及 com.baobaotao.dao.user包下的所有类的所有方法都匹配。“..”出现在类名中时，后面必须跟“*”，表示包、子孙包下的所有类；

execution(* com..*.\*Dao.find*(..))l

匹配包名前缀为com的任何包下类名后缀为Dao的方法，方法名必须以find为前缀。如com.baobaotao.UserDao#findByUserId()、com.baobaotao.dao.ForumDao#findById()的方法都匹配切点。

4)通过方法入参定义切点

切点表达式中方法入参部分比较复杂，可以使用“*”和“ ..”通配符，其中“*”表示任意类型的参数，而“..”表示任意类型参数且参数个数不限。

execution(* joke(String,int)))l

匹 配joke(String,int)方法，且joke()方法的第一个入参是String，第二个入参是int。它匹配 NaughtyWaiter#joke(String,int)方法。如果方法中的入参类型是java.lang包下的类，可以直接使用类名，否则必须使用全限定类名，如joke(java.util.List,int)；

execution(* joke(String,*)))l

匹 配目标类中的joke()方法，该方法第一个入参为String，第二个入参可以是任意类型，如joke(String s1,String s2)和joke(String s1,double d2)都匹配，但joke(String s1,double d2,String s3)则不匹配；

execution(* joke(String,..)))l

匹配目标类中的joke()方法，该方法第 一个入参为String，后面可以有任意个入参且入参类型不限，如joke(String s1)、joke(String s1,String s2)和joke(String s1,double d2,String s3)都匹配。

execution(* joke(Object+)))l

匹 配目标类中的joke()方法，方法拥有一个入参，且入参是Object类型或该类的子类。它匹配joke(String s1)和joke(Client c)。如果我们定义的切点是execution(* joke(Object))，则只匹配joke(Object object)而不匹配joke(String cc)或joke(Client c)。

args()和@args()

args()函数的入参是类名，@args()函数的入参必须是注解类的类名。虽然args()允许在类名后使用+通配符后缀，但该通配符在此处没有意义：添加和不添加效果都一样。

1)args()

该函数接受一个类名，表示目标类方法入参对象按类型匹配于指定类时，切点匹配，如下面的例子：

args(com.baobaotao.Waiter)

表 示运行时入参是Waiter类型的方法，它和execution(* *(com.baobaotao.Waiter))区别在于后者是针对类方法的签名而言的，而前者则针对运行时的入参类型而言。如 args(com.baobaotao.Waiter)既匹配于addWaiter(Waiter waiter)，也匹配于addNaiveWaiter(NaiveWaiter naiveWaiter)，而execution(* *(com.baobaotao.Waiter))只匹配addWaiter(Waiter waiter)方法；实际上，args(com.baobaotao.Waiter)等价于execution(* *(com.baobaotao.Waiter+))，当然也等价于args(com.baobaotao.Waiter+)。

2)@args()

该函数接受一个注解类的类名，当方法的运行时入参对象标注发指定的注解时，方法匹配切点。这个切点函数的匹配规则不太容易理解，我们通过以下示意图对此进行详细讲解：

```
        图 4 @arg(M)匹配示意图(1)
T0、T1、T2、T3具有如图所示的继承关系，假设目标类方法的签名为fun(T1 t)，它的入参为T1，而切面的切点定义为@args(M)，T2类标注了@M。当fun(T1 t)传入对象是T2或T3时，则方法匹配@args(M)所声明定义的切点；
123
```

再看下面的情况，假设方法签名是fun(T1 t)，入参对于T1，而标注@M的类是T0，当funt(T1 t)传入T1、T2、T3的实例时，均不匹配切点@args(M)。

```
        图 5 @arg(M)匹配示意图(2)
在类的继承树中，①点为方法签名中入参类型在类继承树中的位置，我们称之为入参类型点，而②为标注了@M注解的类在类继承树中位置，我们称之为注解点。判断方法在运行时是否匹配@agrs(M)切点，可以根据①点和②点在类继承树中的相对位置来判别：
123
```

\1) 如果在类继承树中注解点②高于入参类型点①，则该目标方法不可能匹配切点@args(M)，如图 5所示；

\2) 如果在类继承树中注解点②低于入参类型点①，则注解点所在类及其子孙类作为方法入参时，该方法匹配@args(M)切点，如图 4所示。

下 面举一个具体的例子，假设我们定义这样的切点：@args(com.baobaotao.Monitorable) ，如果NaiveWaiter标注了@Monitorable，则对于WaiterManager#addWaiter(Waiter w)方法来说，如果入参是NaiveWaiter或其子类对象，该方法匹配切点，如果入参是NaughtyWaiter对象，不匹配切点。如果 Waiter标注了@Monitorable，但NaiveWaiter未标注@Monitorable，则 WaiterManager#addNaiveWaiter(NaiveWaiter w)却不匹配切点，这是因为注解点（在Waiter）高于入参类型点（NaiveWaiter）。