# 日常使用只要记住下图6个命令

![图片](16.png)

**Workspace**：工作区，就是你平时存放项目代码的地方

**Index / Stage**：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息

**Repository**：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本

**Remote**：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换

# 操作命令

## 普通目录变工作目录

### git init

只有在工作目录中才能执行git命令



## 工作目录到暂存区 Workspace —> Index

### git add code.txt

将工作区的code.txt文件添加到暂存区

### git add .

将工作区所有文件（除去.gitignore文件配置忽略的）添加到暂存区

要删除刚刚提交到本地仓库的某个文件，只需要在工作目录删除，接着`git add .`，最后`git commit -m ”xxx“`，本地仓库那个被删的文件就没有了

### git diff

查看工作目录与暂存区的差异

注意：

- 是查看**暂存区的文件**在**工作目录**中有没有**被修改**
- 工作目录**新建文件**diff命令是看不出差异的，他会自动add到暂存区
- 工作目录**重命名文件**，diff命令看作**删除**了原文件及其内容，然后**新建**了一个文件，新建文件会自动add，不显示这部分差异

执行`git add .`后，差异将消失，因为工作目录内容提交到暂存区了

```bash
#工作目录删除了test.txt
$ git diff
diff --git a/test.txt b/test.txt
deleted file mode 100644
index e69de29..0000000

#工作目录在test.txt中插入了内容：asas
$ git diff
diff --git a/test.txt b/test.txt
index e69de29..cb5a377 100644
--- a/test.txt
+++ b/test.txt
@@ -0,0 +1 @@
+asas
\ No newline at end of file

#工作目录在test.txt中删除了内容：asas
$ git diff
diff --git a/test.txt b/test.txt
deleted file mode 100644
index cb5a377..0000000
--- a/test.txt
+++ /dev/null
@@ -1 +0,0 @@
-asas
\ No newline at end of file


#工作目录在test.txt中插入了内容：hello
#但是显示差异为，删除了asas，然后插入了asashello
$ git diff
diff --git a/test.txt b/test.txt
index cb5a377..2e66821 100644
--- a/test.txt
+++ b/test.txt
@@ -1 +1 @@
-asas
\ No newline at end of file
+asashello
\ No newline at end of file

#工作目录在test2.txt重命名为test3.txt
#只显示test2.txt被删除了，只有commit时才能看到test2.txt重命名为test3.txt
$ git diff
diff --git a/test2.txt b/test2.txt
deleted file mode 100644
index b08ccd7..0000000
--- a/test2.txt
+++ /dev/null
@@ -1,2 +0,0 @@
-asashello
-tom
\ No newline at end of file

#工作目录在test5.txt的第2和第3行之间插入了一个主函数代码
$ git diff
diff --git a/test5.txt b/test5.txt
index 2c116c0..e4cf6d6 100644
--- a/test5.txt
+++ b/test5.txt
@@ -1,4 +1,6 @@
 public class Car
 {
+       punlic static void main(String[] args){

+       }
 }
\ No newline at end of file
```



## 暂存区到本地仓库 index —> Repository

### git commit -m "备注信息"

将暂存区的所有文件提交到本地仓库

注意：提交完的暂存区不会清空，不然的话下次add一个文件commit一下，本地仓库可就只剩这一个文件了，要是不小心push了会出大问题



## 本地仓库到远程仓库 Repository —> Remote

### git push --force \<origin> <本地分支>:<远程分支>

--force：当本地git和远程git版本相差过大，不允许push，可以加上这个强制push

`git push --force git@gitee.com:hushushu/git-test.git dev:master`



## 远程仓库到本地仓库 Remote—> Repository 

### git clone \<origin>

`git  clone https://git.coding.net/aiyongbao/tradepc.git`：克隆所有分支，可以通过git checkout dev5切换dev5分支

`git clone -b dev5 https://git.coding.net/aiyongbao/tradepc.git`：克隆该仓库的dev5分支

ssh连接只能push开源仓库，需要设置好公钥

https连接开源push私有仓库，需要输入邮箱和密码

### git pull \<origin>

**clo**ne 是本地没有 repository 时，将远程 repository 整个下载过来。 pull 是本地有 repository 时，将远程 repository 里新的 commit 数据 (如有的话)下载过来，并且与本地代码merge。 note：git pull相当于git fetch和git merge。



## 本地仓库到工作目录 Repository —> Workspace

### git checkout \<branch>

所有分支的文件其实都在本地仓库，当更改分支时，例如master—>dev，工作目录的文件会从master分支文件变成dev分支文件

切换分支前不需要add和commit，但是最好add然后commit一下



## 分支操作

### git branch

注意：这里的origin不需要改成仓库地址

```bash
#更新远程分支列表（可能没用）
git remote update origin --prune
#本地创建一个develop分支，切换develop，将远程develop分支拉取过来
git checkout -b develop origin/develop

#查看所有分支
git branch -a

#删除远程分支Chapater6
git push origin --delete Chapater6

#删除本地分支 Chapater6
git branch -d  Chapater6
```



### git pull \<origin>

git fetch + git merge == git pull，将远程的新commit的记录下载过来，然后直接合并

### git merge \<branch>

假如现在是dev分支，将master分支合并到当前dev分支

建议先把远程dev的代码pull下来，再将master分支合并进来，保证最新

合并master分支并不是把master分支的代码都下载下来，而是将上一次合并到这一次之间master分支的commit合并进来

合并之后需要add和commit，否则分支将一直停留在MERGING状态，无法切换分支

```bash
#如果报错：fatal: refusing to merge unrelated histories
#是因为两个分支没有取得关系，需要在命令后面加上--allow-unrelated-histories
git merge master --allow-unrelated-histories

#如果存在相同的文件不同的内容，导致冲突，可以手动选择保留那一部分
# -------------------------------------------------------
#dev分支的java.txt内容
void hello{
	hello
}
#master分支的java.txt内容
psvm
hello

#合并之后dev分支的java.txt内容，可自己选择要保留哪一部分
<<<<<<< HEAD
void hello{
	hello
}
=======
psvm
hello
>>>>>>> master

# -------------------------------------------------------
#dev分支的java.txt内容
void hello{
	hello
}
void test{
	test
}
#master分支的java.txt内容，hello方法的内容不同
void hello{
	hi
}
void test{
	test
}
#合并之后dev分支的java.txt
void hello{
<<<<<<< HEAD
	hello
=======
	hi
>>>>>>> master
}
void test{
	test
}
```

