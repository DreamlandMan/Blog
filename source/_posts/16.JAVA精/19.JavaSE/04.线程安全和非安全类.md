## **线程安全(Thread-safe)的集合对象：**

### Vector 

- Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。 
- Vector和ArrayList在使用上非常相似，都可以用来表示一组数量可变的对象应用的集合，并且可以随机的访问其中的元素。

### HashTable

- 是线程安全的； 
- 无论是key还是value都不允许有null值的存在；在HashTable中调用Put方法时，如果key为null，直接抛出NullPointerException异常； 
- 遍历使用的是Enumeration列举；

### StringBuffer

- StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串。
- 在执行速度方面的比较：StringBuilder > StringBuffer ； 
- 他们都是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的，不像String一样创建一些对象进行操作，所以速度快；
- 如果要操作少量的数据用 = String 
- 单线程操作字符串缓冲区 下操作大量数据 = StringBuilder 
- 多线程操作字符串缓冲区 下操作大量数据 = StringBuffer

### 以Concurrent开头的集合类

- 如 **ConcurrentHashMap**、**ConcurrentLinkedQueue**、**ConcurrentLinkedDeque**、**ConcurrentSkipListMap**和**ConcurrentSkipListSet** 

- 其中以Concurrent开头的集合类代表了支持并发访问的集合，它们可以支持多个线程并发写入访问，这些写入线程的所有操作都是线程安全的，但读取操作不必锁定。以Concurrent开头的集合类采用了更复杂的算法来保证永远不会锁住整个集合，因此在并发写入时有较好的性能。

- 当多个线程共享访问一个公共集合时，ConcurrentLinkedQueue是一个恰当的选择。ConcurrentLinkedQueue不允许使用null元素。ConcurrentLinkedQueue实现了多线程的高效访问，多个线程访问ConcurrentLinkedQueue集合时无须等待。

- 在默认情况下，ConcurrentHashMap支持16个线程并发写入，当有超过16个线程并发向该Map中写入数据时，可能有一些线程需要等待。实际上，程序通过设置concurrencyLevel构造参数(默认值为16)来支持更多的并发写入线程。

  与前面介绍的HashMap和普通集合不同的是，因为ConcurrentLinkedQueue和ConcurrentHashMap支持多线程并发访问，所以当使用迭代器来遍历元素时，该迭代器可能不能反映出创建迭代器之后所做的修改，但程序不会抛出任何异常。

  Java8拓展了ConcurrentHashMap的功能，为该类新增了30多个新方法，这些方法可借助于Stream和Lambda表达式支持执行聚焦操作。ConcurrentHashMap新增的方法大致可分为如下三类：

  - forEach系列（forEach、forEachKey、forEachValue、forEachEntry）
  - search系列（search、searchKeys、searchValues、searchEntries）
  - reduce系列（reduce 、reduceToDouble、reduceToLong、searchKeys、searchValues）

- 除此之外，ConcurrentHashMap还新增了mappingCount()、newKeySet()等方法，增强后的ConcurrentHashMap更适合作为缓存实现类使用。

  >注意:
  >使用java.util包下的Collection作为集合对象时,如果该集合对象创建迭代器集合元素发生改变,则会引发ConcurrentModificationException异常.

### 以CopyOnWrite开头的集合类

如 **CopyOnWriteArrayList**、**CopyOnWriteArraySet**

- 由于CopyOnWriteArraySet的底层封装了CopyOnWriteArrayList，因此它的实现机制完全类似于CopyOnWriteList集合。

- 对应CopyOnWriteArrayList集合，正如它的名字所暗示的，它采用复制底层数组的方式来实现写操作。

- 当线程对CopyOnWriteArrayList集合执行读取操作时，线程将会直接读取集合本身，无须加锁与阻塞。当线程对CopyOnWriteArrayList集合执行写入操作时(包括调用add()、remove()、set()等方法)，该集合会在底层复制一份新的数组，接下来对新的数组执行写入操作。由于对CopyOnWriteArrayList集合的写入操作都是对数组的副本执行操作，因此它是线程安全的。

- 需要指出的是，由于CopyOnWriteArrayList执行写入操作时需要频繁地复制数组，性能比较差，但由于读操作与写操作不是操作同一个数组，并且读操作也不需要加锁，因此读操作就很快、很安全。由此可见，CopyOnWriteArrayList适合用在读取操作远远大于写入操作的场景中，比如缓存等。

## **非线程安全的集合对象：**

### ArrayList 

-  当操作是在一列数据的后面添加数据而不是在前面或者中间，并需要随机地访问其中的元素时，使用ArrayList性能比较好。 
-  ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。

### LinkedList

- 当对一列数据的前面或者中间执行添加或者删除操作时，并且按照顺序访问其中的元素时，要使用LinkedList。 
- LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。

### HashMap

- 采用数组方式存储key-value构成的Entry对象，无容量限制； 
- 基于key hash查找Entry对象存放到数组的位置，对于hash冲突采用链表的方式去解决； 
- 在插入元素时，可能会扩大数组的容量，在扩大容量时须要重新计算hash，并复制对象到新的数组中； 
- 遍历使用的是Iterator迭代器；

### HashSet

- 基于HashMap实现，无容量限制； 
- 不保证数据的有序；

### TreeMap

-  典型的基于红黑树的Map实现，因此它要求一定要有key比较的方法，要么传入Comparator比较器实现，要么key对象实现Comparator接口； 

### TreeSet

- 基于TreeMap实现的，支持排序； 

### StringBulider

- StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串。
- 在执行速度方面的比较：StringBuilder > StringBuffer ； 
- 他们都是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的，不像String一样创建一些对象进行操作，所以速度快； 
- 如果要操作少量的数据用 = String 
- 单线程操作字符串缓冲区 下操作大量数据 = StringBuilder 
- 多线程操作字符串缓冲区 下操作大量数据 = StringBuffer

