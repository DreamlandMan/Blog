#### 容器数据卷

- Docker理念回顾：将应用和环境打包成一个镜像。但是数据总不能放在容器里吧，一旦容器删除就丢失了，比如MYSQL容器，容器删了=删库跑路，总不能每次删除前都把容器打包一遍吧。怎样才能做到数据持久化呢？
- 容器之间能不能有一个数据共享的技术？将Docker容器中产生的数据映射到本地！
- 这就是卷技术！目录的挂载，将容器内的目录挂载到主机上。
- 总结：卷技术就是为了容器的持久化和映射技术！支持容器间以及容器和主机之间的数据共享

#### 数据卷作用总结

- 数据卷就是目录或文件，存在于一个或多个容器中，由Docker挂载到容器，但不属于联合文件系统，因此能够绕过Union FileSystem（联合文件系统），提供一些用于持续存储或共享数据的特性。
- 数据卷的设计目的就是为了Doeker容器中数据的持久化，完全独立于容器的生存周期，Docker不会在容器删除时，删除其挂载的数据卷。
- **数据卷**
  - 数据卷可在容器之间共享或重用数据。
  - 数据卷中的更改可以直接生效。
  - 数据卷中的更改不会包含在镜像的更新中。
  - 数据卷的生命周期一直持续到没有容器使用它为止。

####  数据卷的使用

- 使用-v参数给容器添加数据卷，Volume（卷）的首字母。

  - 使用跟-p差不多，主机目录:容器目录
  - 主机内目录和容器内目录挂载，当主机内或者容器内目录数据改变，其在容器或主机的映射目录的数据也会相应改变，有点像**双向绑定**
  - 其实挂载并不是同步，看起来像同步而已，同步是两个一样的文件，挂载只有一个文件，挂载是主机文件向容器内挂载，容器内文件对于主机内文件其实就相当于Windows中的快捷方式，二者操作的其实都是同一个文件，只是看起看不同而已
  - 哪怕**容器停止也能挂载**，只要容器没有删除，主机内目录数据改变，挂载的容器内目录数据也还会映射改变
  - **好处**
    - 以后操作数据只要在主机上操作就可以了，非必要的话不需要开启容器
    - 多个容器可以通过挂载同一个主机目录达到数据共享，会不会出现数据一致性问题呢？

  ```shell
  # 方式1：使用命令来挂载 -v，将主机目录和容器目录连接起来
  docker run -it -v 主机目录：容器目录 容器Id
  
  #实例，用两个面板操作，序号表示操作顺序，#####用来分隔两个面板命令
  #################################
  #1.进入centos容器
  [root@iZ0jldalqlhwtqori6z48lZ ~]# docker run -it -v /home/test:/home centos /bin/bash
  Unable to find image 'centos:latest' locally
  latest: Pulling from library/centos
  a1d0c7532777: Pull complete 
  ...
  [root@edde58707fec /]# cd home
  [root@edde58707fec home]# ls
  [root@edde58707fec home]# touch test.txt #在容器中创建一个文件，看看主机映射目录有没有创建
  [root@edde58707fec home]# ls
   test.txt
   
   #3.创建hello.txt
  [root@iZ0jldalqlhwtqori6z48lZ test]# touch hello.txt
  
  #6.在容器停止的状态下，修改主机的映射目录中的hello.txt
  [root@iZ0jldalqlhwtqori6z48lZ test]# vim hello.txt #在hello.txt中输入hello,linux update!
  
  #################################
  #2.另一个连接
  [root@iZ0jldalqlhwtqori6z48lZ ~]# cd /home
  [root@iZ0jldalqlhwtqori6z48lZ home]# ls
  test
  [root@iZ0jldalqlhwtqori6z48lZ home]# cd test
  [root@iZ0jldalqlhwtqori6z48lZ test]# ls
  [root@iZ0jldalqlhwtqori6z48lZ test]# ls #和容器内映射目录一样创建了该文件
  test.txt
  
  #4.查看有映射创建hello.txt
  [root@edde58707fec home]# ls
   hello.txt   test.txt
   
  #5.退出容器，在容器停止时看看挂载还能不能生效
  [root@edde58707fec home]# exit
  exit
  [root@iZ0jldalqlhwtqori6z48lZ ~]# docker ps
  CONTAINER ID   IMAGE     COMMAND       CREATED       STATUS             PORTS     NAMES
  edde58707fec   centos    "/bin/bash"   5 hours ago   Up About an hour             cranky_meitner
  [root@iZ0jldalqlhwtqori6z48lZ ~]# docker stop edde58707fec #停止容器，看看停止容器后挂载还能不能挂载生效
  edde58707fec
  
  #启动容器，看看挂载有没有生效
  [root@iZ0jldalqlhwtqori6z48lZ ~]# docker start edde58707fec
  edde58707fec
  [root@iZ0jldalqlhwtqori6z48lZ home]# docker attach edde58707fec
  [root@edde58707fec /]# cd home
  [root@edde58707fec home]# cat hello.txt #查看后发现容器关闭后挂载依旧能够成功生效
  hello,linux update!
  ```

- **docker inspect** 查看容器元数据，**Mounts**是挂载信息

  ```shell
  [root@iZ0jldalqlhwtqori6z48lZ test]# docker ps
  CONTAINER ID   IMAGE     COMMAND       CREATED       STATUS          PORTS     NAMES
  edde58707fec   centos    "/bin/bash"   4 hours ago   Up 47 minutes             cranky_meitner
  [root@iZ0jldalqlhwtqori6z48lZ test]# docker inspect edde58707fec
  [
      {
          "Id": "edde58707fec6dafb321c89f0f77a78e135e085162263d95035f65412baff782",
          "Created": "2022-02-24T07:26:27.443576008Z",
          "Path": "/bin/bash",
          "Args": [],
          ...
          "Mounts": [
              {
                  "Type": "bind", #挂载方式：绑定
                  "Source": "/home/test", #主机内地址，因为挂载是主机往容器挂，所以主机地址是源
                  "Destination": "/home", #容器内地址
                  "Mode": "",
                  "RW": true,
                  "Propagation": "rprivate"
              }
          ],
          ...
  ```

  

